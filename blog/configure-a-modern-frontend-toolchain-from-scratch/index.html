<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>从零开始，配置一套现代前端工具链</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="博客文章 RSS 订阅" href="https://skywt.cn/rss.xml"><link rel="sitemap" href="/sitemap-index.xml"><title>从零开始，配置一套现代前端工具链</title><link rel="canonical" href="https://skywt.cn/blog/configure-a-modern-frontend-toolchain-from-scratch/"><meta name="description" content="现代前端应用框架（如 Next.js、Nuxt.js 等）都直接集成了完整的工具链，按照官方文档做，一行命令就可以配置完毕。这整套工具在我们调试和构建项目时，在背后做了大量工作。虽然这有助于快速上手，但是非常不利于我们了解其中的原理。

然而，各种工具纷繁复杂，文档浩如烟海。由于工具之多，即使文档再友好、工具本身再易用，也很难快速入门。

**本文将带你踏上一段旅程，从一个空文件夹开始，一步一步添加工具，最终配置一套完整的前端工具链。**在其中，我们可以对各个工具的概念、用途和原理有一个比较系统的认识。每个部分都列出了相关文档的链接，方便查阅。

"><meta name="robots" content="index, follow"><meta property="og:title" content="从零开始，配置一套现代前端工具链"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://skywt.cn/blog/configure-a-modern-frontend-toolchain-from-scratch/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="SkyWT"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@skywt2003"><meta name="twitter:title" content="从零开始，配置一套现代前端工具链"><meta name="twitter:image" content="/og.svg"><meta name="twitter:image:alt" content="SkyWT"><meta name="twitter:description" content="现代前端应用框架（如 Next.js、Nuxt.js 等）都直接集成了完整的工具链，按照官方文档做，一行命令就可以配置完毕。这整套工具在我们调试和构建项目时，在背后做了大量工作。虽然这有助于快速上手，但是非常不利于我们了解其中的原理。

然而，各种工具纷繁复杂，文档浩如烟海。由于工具之多，即使文档再友好、工具本身再易用，也很难快速入门。

**本文将带你踏上一段旅程，从一个空文件夹开始，一步一步添加工具，最终配置一套完整的前端工具链。**在其中，我们可以对各个工具的概念、用途和原理有一个比较系统的认识。每个部分都列出了相关文档的链接，方便查阅。

"><meta name="twitter:creator" content="@skywt2003"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.15.4"><meta name="keywords" content="前端,配置,Webpack,React.js,TypeScript,PostCSS,Tailwind,ESLint"><script>
      function addMatomo() {
        var _paq = (window._paq = window._paq || []);
        _paq.push(["trackPageView"]);
        _paq.push(["enableLinkTracking"]);
        (function () {
          var u = "//analytics.skywt.cn/";
          _paq.push(["setTrackerUrl", u + "matomo.php"]);
          _paq.push(["setSiteId", "1"]);
          var d = document,
            g = d.createElement("script"),
            s = d.getElementsByTagName("script")[0];
          g.async = true;
          g.src = u + "matomo.js";
          s.parentNode.insertBefore(g, s);
        })();
      }

      document.addEventListener(
        "astro:page-load",
        () => {
          addMatomo();
        },
        { once: false },
      );
    </script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.D_JCtxLP.css">
<link rel="stylesheet" href="/_astro/about.CeG4KcMB.css"><script type="module" src="/_astro/hoisted.BaJnAOVi.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
从零开始，配置一套现代前端工具链 </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
从零开始，配置一套现代前端工具链 </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv> <i class="ri-contacts-line" data-astro-cid-tfcnbjmv></i> 友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top">  <h1 class="page__heading">从零开始，配置一套现代前端工具链</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2024 年 3 月 16 日 07:31</span>  <br> <i class="ri-discuss-line"></i> <span>共 2 条评论</span>  </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#tldr">TL；DR</a></li>
<li><a href="#%E4%BB%8E%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-npm-%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%A7%8B">从创建一个 npm 项目开始</a></li>
<li><a href="#webpack">Webpack</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8">安装与使用</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-webpackconfigjs">配置文件 webpack.config.js</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE-npm-scripts">设置 npm scripts</a></li>
<li><a href="#%E7%94%9F%E6%88%90-html">生成 HTML</a></li>
<li><a href="#%E4%BD%BF%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5-import-css-%E6%96%87%E4%BB%B6">使代码可以 import CSS 文件</a></li>
</ul></li>
<li><a href="#postcss">PostCSS</a>
<ul>
<li><a href="#%E9%9B%86%E6%88%90%E5%88%B0-webpack">集成到 webpack</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-postcssconfigjs">配置文件 postcss.config.js</a></li>
</ul></li>
<li><a href="#tailwind-css">Tailwind CSS</a>
<ul>
<li><a href="#%E9%9B%86%E6%88%90%E5%88%B0-postcss">集成到 PostCSS</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-tailwindconfigjs">配置文件 tailwind.config.js</a></li>
<li><a href="#%E5%AE%89%E8%A3%85-tailwind-%E6%8F%92%E4%BB%B6">安装 Tailwind 插件</a></li>
</ul></li>
<li><a href="#%E4%B8%AD%E5%9C%BA%E4%BC%91%E6%81%AF%E6%95%B4%E7%90%86%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">中场休息：整理目录结构</a></li>
<li><a href="#babel">Babel</a>
<ul>
<li><a href="#%E9%9B%86%E6%88%90%E5%88%B0-webpack-1">集成到 webpack</a></li>
<li><a href="#presets">presets</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-babelconfigjson">配置文件 babel.config.json</a></li>
<li><a href="#preset-env">preset-env</a></li>
</ul></li>
<li><a href="#typescript">TypeScript</a>
<ul>
<li><a href="#%E9%9B%86%E6%88%90%E5%88%B0-babel">集成到 Babel</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-tsconfigjson">配置文件 tsconfig.json</a></li>
</ul></li>
<li><a href="#reactjs">React.js</a>
<ul>
<li><a href="#%E9%9B%86%E6%88%90%E5%88%B0-babel-1">集成到 Babel</a></li>
<li><a href="#%E7%BC%96%E5%86%99-react-%E7%BB%84%E4%BB%B6">编写 React 组件</a></li>
</ul></li>
<li><a href="#eslint">ESLint</a>
<ul>
<li><a href="#%E9%9B%86%E6%88%90%E5%88%B0-webpack-2">集成到 webpack</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-eslintrcjs">配置文件 .eslintrc.js</a></li>
</ul></li>
<li><a href="#recap%E7%AB%99%E5%9C%A8%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80%E4%B8%8A">Recap：站在巨人的肩膀上</a>
<ul>
<li><a href="#%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83-%F0%9F%A4%94">一点思考 🤔</a></li>
</ul></li>
<li><a href="#%E5%80%BC%E5%BE%97%E4%B8%80%E8%AF%BB">值得一读</a></li>
</ul>
<p>现代前端应用框架（如 Next.js、Nuxt.js 等）都直接集成了完整的工具链，按照官方文档做，一行命令就可以配置完毕。这整套工具在我们调试和构建项目时，在背后做了大量工作。虽然这有助于快速上手，但是非常不利于我们了解其中的原理。</p>
<p>然而，各种工具纷繁复杂，文档浩如烟海。由于工具之多，即使文档再友好、工具本身再易用，也很难快速入门。</p>
<p><strong>本文将带你踏上一段旅程，从一个空文件夹开始，一步一步添加工具，最终配置一套完整的前端工具链。</strong>在其中，我们可以对各个工具的概念、用途和原理有一个比较系统的认识。每个部分都列出了相关文档的链接，方便查阅。</p>
<!--more-->
<p>我们使用 <strong>React.js</strong> 前端框架，使用 <strong>Tailwind</strong> 编写 CSS，使用 <strong>TypeScript</strong> 编写脚本，并使用 <strong>ESLint</strong> 进行代码检查。最终，希望达到和使用 create-react-app 工具创建的项目类似的开发体验。</p>
<h2><a id="tldr" class="content__heading-anchor"></a>TL；DR</h2>
<p><strong>配置完毕后，整套工具链的示意图如下：</strong></p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/03/543791890.png" data-fancybox data-caption="配置完毕后的工具链示意图"><img src="https://blog.skywt.cn/usr/uploads/2024/03/543791890.png" alt="配置完毕后的工具链示意图" title="配置完毕后的工具链示意图" /></a></p>
<h2><a id="从创建一个-npm-项目开始" class="content__heading-anchor"></a>从创建一个 npm 项目开始</h2>
<p>创建一个空目录（一般目录名就是项目名），进入其中执行 <code>npm init</code>，这个命令会交互式地让你填写该项目的元信息。</p>
<p>我们将这个项目命名为 <strong>study-chain</strong>（意为 study frontend toolchain）：</p>
<pre><code class="language-bash"><span class="hljs-built_in">mkdir</span> study-chain
<span class="hljs-built_in">cd</span> study-chain
npm init
</code></pre>
<p>确认信息之后，目录下会生成 <code>package.json</code> 文件，记录了项目的元信息：</p>
<pre><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;study-chain&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.0.0&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;main&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;index.js&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;author&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SkyWT&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;license&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ISC&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>接下来，我们以 <strong>moment</strong> 模块为例，这是一个用于转换日期格式的模块（这个模块其实已经废弃，不推荐新项目使用。我们只是将其作为示例，参见<a href="https://momentjs.com/docs/">文档</a>）。</p>
<p>在项目根目录下，使用 <code>npm i</code> 安装模块：</p>
<pre><code class="language-bash">npm i moment
</code></pre>
<p>我们只使用这个模块的一个功能为例：将模块引入为 <code>moment</code> 之后，<code>moment().format()</code> 返回当前日期时间字符串。</p>
<h2><a id="webpack" class="content__heading-anchor"></a>Webpack</h2>
<p>让我们先忘掉 React.js，从编写纯 HTML 和 JavaScript 开始。<strong>如何在这个项目里使用之前安装的 moment 模块呢？</strong></p>
<p>考虑编写一个简单的 HTML 文件 <code>index.html</code>：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>这个 HTML 引用了 <code>index.js</code>。这个 js 文件引入了 moment 模块，将 div 内的内容设置为当前时间：</p>
<pre><code class="language-js"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">const</span> moment = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;moment&quot;</span>);

<span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>);
app.<span class="hljs-property">innerText</span> = <span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>();
</code></pre>
<p><strong>当然，如果此时在浏览器中打开 HTML，这段 js 是无法运行的。</strong>因为 require 是 Node.js 的语法，浏览器并不支持。</p>
<p><strong>但是我们知道这个模块就在本地</strong>，它的源文件就在 <code>node_modules/moment</code> 路径下。我们需要一个工具<strong>获取这个模块，整合进这段 js 里</strong>。这种工具就叫做 <strong>bundler</strong>。有了 bundler，即使在用于前端的 js 中，我们也能引入模块了。</p>
<p><strong>Webpack</strong> 就是其中之一。</p>
<p><strong>类似的工具有：</strong>Rollup、Parcel。</p>
<h3><a id="安装与使用" class="content__heading-anchor"></a>安装与使用</h3>
<p>首先安装 webpack 和 webpack-cli。后者是配套的命令行工具。这两个工具都只是在开发阶段使用，所以使用 <code>--save-dev</code> 安装为开发环境依赖：</p>
<pre><code class="language-bash">npm i webpack webpack-cli --save-dev
</code></pre>
<p>安装后，可以直接使用 <code>npx webpack</code> 命令：</p>
<pre><code class="language-bash">npx webpack ./index.js --mode=development
</code></pre>
<p>这个命令处理 <code>index.js</code> 文件，解析其中引用的模块，将对应的 js 代码注入该文件。参数 <code>--mode=development</code> 指示生成开发环境下易于调试的文件版本。如果在生产环境，应使用 <code>--mode=production</code>。</p>
<p>运行之后，会生成 <code>dist/main.js</code>（这是默认的输出文件，可配置），这就相当于<strong>浏览器版</strong>的源文件。于是，修改 HTML 中引用的 script 路径：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./dist/main.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>用浏览器打开，可以发现成功地调用了该模块，div 中显示了当前的日期时间。</p>
<p>使用 <code>--watch</code> 参数可以使 webpack 保持运行，持续监听源文件的修改：</p>
<pre><code class="language-bash">npx webpack ./index.js --mode=development --watch
</code></pre>
<p>运行时，每当编辑 <code>index.js</code> 并保存，都会自动重新生成 <code>dist/main.js</code> 文件。可以在终端看到对应的输出。</p>
<p>除了 <code>require</code> 语法，webpack 也支持更常用的 <code>import</code> 语法。刚才的引入模块语句可以改成：</p>
<pre><code class="language-js"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;
<span class="hljs-comment">// ...</span>
</code></pre>
<h3><a id="配置文件-webpackconfigjs" class="content__heading-anchor"></a>配置文件 webpack.config.js</h3>
<p>使用 webpack 的配置文件，可以替代运行命令时传递的参数，让命令行的使用更简洁和灵活。（<a href="https://webpack.js.org/configuration/">相关文档</a>）</p>
<p>在项目根目录创建名为 <code>webpack.config.js</code> 的文件，内容如下：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./index.js&#x27;</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;main.js&#x27;</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>)
  }
};
</code></pre>
<p>创建了配置文件之后，使用命令行时，只需要使用如下命令：</p>
<pre><code class="language-bash">npx webpack
npx webpack --watch
</code></pre>
<h3><a id="设置-npm-scripts" class="content__heading-anchor"></a>设置 npm scripts</h3>
<p>为了方便起见，可以将以上 webpack 命令设置为 <strong>npm scripts</strong>。</p>
<p>编辑 <code>package.json</code> 文件，添加 scripts：</p>
<pre><code class="language-json"><span class="hljs-comment">// package.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;watch&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --watch&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-comment">// ...</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>保存之后，只需使用如下命令，就等同于运行设置的 webpack 命令：</p>
<pre><code class="language-bash">npm run build
npm run watch
</code></pre>
<p>为了表述方便，下文将运行 <code>npm run build</code> 命令的这一操作简称为 build。</p>
<h3><a id="生成-html" class="content__heading-anchor"></a>生成 HTML</h3>
<p>现在，构建完成后，访问 <code>index.html</code> 就能看到我们的网站。然而可以发现，这个 HTML 中 <code>main.js</code> 需要我们手动引用。能否让 webpack 帮我们完成这件事情呢？</p>
<p>这就需要让 webpack 为我们在 <code>dist</code> 目录中<strong>生成 HTML 文件</strong>。这可以通过 <strong>html-webpack-plugin</strong> 这个插件实现。没错，<strong>webpack 不仅是一个打包工具，其还拥有着丰富的插件生态</strong>。</p>
<p>运行以下命令安装 html-webpack-plugin（<a href="https://webpack.js.org/plugins/html-webpack-plugin/">文档</a>）：</p>
<pre><code class="language-bash">npm i html-webpack-plugin --save-dev
</code></pre>
<p>将 <code>index.html</code> 重命名为 <code>template.html</code>，内容如下：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>接下来修改 <code>webpack.config.js</code>，添加 html-webpack-plugin 插件的配置：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);
<span class="hljs-comment">// ...</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({
      <span class="hljs-attr">template</span>: <span class="hljs-string">&quot;template.html&quot;</span>
    })
  ]
};
</code></pre>
<p>再次使用 build 构建，会发现 <code>dist</code> 目录下生成了 <code>index.html</code>，这个 HTML 引用了生成的 <code>main.js</code> 脚本。打开就能看见其实现了我们要的应用逻辑。</p>
<h3><a id="使代码可以-import-css-文件" class="content__heading-anchor"></a>使代码可以 import CSS 文件</h3>
<p>现在，有了 webpack 的加持，我们的 js 代码已经可以导入 module 了。但是如果需要引入其他静态资源，比如 CSS 文件，还是无法直接完成。为了使代码能直接 import 其他类型的文件，<strong>webpack 中可以安装配置一种称为 loader 的模块</strong>。</p>
<p>💡 <strong>Webpack 中的 loader 与 plugin：</strong>二者都是可以集成到 webpack 的模块，但是两个不同的概念。loader 一般用于处理特定类型的文件，而 plugin 可以提供更加广泛的功能。</p>
<p>比如，为了引入 CSS 文件，可以安装 <strong>style-loader</strong> 和 <strong>css-loader</strong> 两个模块（<a href="https://webpack.js.org/guides/asset-management/#loading-css">相关文档</a>）：</p>
<pre><code class="language-bash">npm i style-loader css-loader --save-dev
</code></pre>
<p>接下来，修改 webpack 配置文件，添加一条规则：对于文件名以 <code>.css</code> 结尾的文件，使用这两个模块：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>],
      },
    ],
  },
 };
</code></pre>
<p>Webpack 会按照配置的顺序调用 loader。在该配置文件下，先调用 style-loader，再调用 css-loader。这两个 loader 分别的作用是：</p>
<ul>
<li><strong>style-loader</strong>：将一个 CSS 文件注入 DOM，放在 <code>&lt;style&gt;</code> 元素中。（<a href="https://webpack.js.org/loaders/style-loader/">文档</a>）</li>
<li><strong>css-loader</strong>：解析 CSS 中的 <code>@import</code> 和 <code>url()</code> 等语句，将对应引用的文件配置好。（<a href="https://webpack.js.org/loaders/css-loader">文档</a>）</li>
</ul>
<p>现在，可以使用 import 语句导入 CSS 文件了。首先还是在根目录下编写 <code>style.css</code> 文件：</p>
<pre><code class="language-css">// style<span class="hljs-selector-class">.css</span>
<span class="hljs-selector-class">.bg-gray</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#aaa</span>;
}
</code></pre>
<p>保存后，修改 <code>index.js</code> 文件：</p>
<pre><code class="language-js"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>);
app.<span class="hljs-property">innerText</span> = <span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>();

app.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;bg-gray&quot;</span>);
</code></pre>
<p>重新 build 后，打开 HTML 即可发现样式的变化。</p>
<h2><a id="postcss" class="content__heading-anchor"></a>PostCSS</h2>
<p>顾名思义。<strong>PostCSS</strong> 能够对 CSS 文件进行「后处理」（post-processing）。</p>
<p>和之前提到的 style-loader 和 css-loader 一样，PostCSS 也可以作为 loader 集成到 webpack。</p>
<h3><a id="集成到-webpack" class="content__heading-anchor"></a>集成到 webpack</h3>
<p>首先还是安装 <strong>postcss-loader</strong>，同时安装 PostCSS 的一个插件 <strong>autoprefixer</strong>：</p>
<pre><code class="language-bash">npm i postcss-loader autoprefixer --save-dev
</code></pre>
<p>在 <code>webpack.config.js</code> 中添加配置：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/i</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-string">&quot;style-loader&quot;</span>,
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;css-loader&quot;</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>,
            },
          },
          <span class="hljs-string">&quot;postcss-loader&quot;</span>,
        ],
      },
    ],
  },
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>⚠️ <strong>注意：</strong>此处调用 css-loader 处添加了 options，将 <strong>importLoaders</strong> 设置为 1。这是考虑到 PostCSS 可能引入新的 <code>@import</code> 等语句，css-loader 要在其运行之后重新进行解析（<a href="https://webpack.js.org/loaders/css-loader/#importloaders">相关文档</a>）。如果确定 PostCSS 不会添加新的 <code>@import</code> 等语句，则此参数可不加。（可参考 <a href="https://github.com/webpack-contrib/css-loader/issues/228#issuecomment-312885975">GitHub 上的相关讨论</a>）</p>
<h3><a id="配置文件-postcssconfigjs" class="content__heading-anchor"></a>配置文件 postcss.config.js</h3>
<p>接下来创建 PostCSS 的配置文件，项目根目录下的 <code>postcss.config.js</code> 文件（<a href="https://github.com/postcss/postcss?tab=readme-ov-file#webpack">文档</a>）：</p>
<pre><code class="language-js"><span class="hljs-comment">// postcss.config.js</span>
<span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import(&#x27;postcss-load-config&#x27;).Config</span>} */</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;autoprefixer&quot;</span>)],
};
</code></pre>
<p>在以上的配置文件中，我们加载了 PostCSS 的 <strong>autoprefixer</strong> 插件（<a href="https://github.com/postcss/autoprefixer">文档</a>）。由于浏览器支持的差异，部分浏览器中使用某些样式需要加上特定的前缀，比如 <code>webkit</code> 或者 <code>moz</code>，这叫做 <strong>vendor prefix</strong>。这个插件会自动添加这种前缀，确保样式的兼容性。这里使用此插件只是为了演示 PostCSS 插件的使用，因为接下来我们将配置使用 Tailwind 插件。</p>
<p>PostCSS 是 webpack 的插件，autoprefixer 又是 PostCSS 的插件，也就是 webpack 的插件的插件。接下来我们还可以安装 Tailwind 的插件，即 webpack 的插件的插件的插件。<strong>前端工具链就是如此。</strong></p>
<h2><a id="tailwind-css" class="content__heading-anchor"></a>Tailwind CSS</h2>
<p>使用过 Tailwind 之后，在开发任何前端项目时，我的心理状态：</p>
<blockquote>
<p>没有它我不能活！😭😭😭</p>
</blockquote>
<p>是的，之后在开发任何前端项目的时候，我<strong>没有一次</strong>离开过 Tailwind。即使是写纯 HTML 也要从 CDN 引入静态文件。因为它彻底改变了我们编写样式的方式。</p>
<p>作为现代前端项目，Tailwind 当然是必备的工具。</p>
<h3><a id="集成到-postcss" class="content__heading-anchor"></a>集成到 PostCSS</h3>
<p>首先还是安装 Tailwind：</p>
<pre><code class="language-bash">npm install tailwindcss --save-dev
</code></pre>
<p>接下来，在 PostCSS 中添加 Tailwind 插件（<a href="https://tailwindcss.com/docs/installation/using-postcss">官方指南</a>）：</p>
<pre><code class="language-js"><span class="hljs-comment">// postcss.config.js</span>
<span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import(&#x27;postcss-load-config&#x27;).Config</span>} */</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: {
    <span class="hljs-attr">tailwindcss</span>: {},
    <span class="hljs-attr">autoprefixer</span>: {},
  }
};
</code></pre>
<h3><a id="配置文件-tailwindconfigjs" class="content__heading-anchor"></a>配置文件 tailwind.config.js</h3>
<p>下一步，使用以下命令创建 Tailwind 的配置文件：</p>
<pre><code class="language-bash">npx tailwindcss init
</code></pre>
<p>Tailwind 会生成自己的配置文件 <code>tailwind.config.js</code>（<a href="https://tailwindcss.com/docs/configuration">文档</a>）：</p>
<pre><code class="language-js"><span class="hljs-comment">// tailwind.config.js</span>
<span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import(&#x27;tailwindcss&#x27;).Config</span>} */</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">content</span>: [<span class="hljs-string">&quot;./**/*.{html,js}&quot;</span>],
  <span class="hljs-attr">theme</span>: {
    <span class="hljs-attr">extend</span>: {},
  },
  <span class="hljs-attr">plugins</span>: [],
}
</code></pre>
<p>配置文件中的 <strong>content</strong> 的值，是一个字符串数组，其中存放着需要处理的文件路径。Tailwind 会尝试检测所有匹配的文件中出现的 class 值，并添加对应的 CSS 定义。</p>
<p>为了匹配我们根目录下的模板 HTML 和 js 文件，删除路径中 <code>src</code> 部分。（或者也可以将所有源文件放到 <code>src</code> 子目录里——大多数项目都是这样做的。下一步在整理文件环节，我们也会这样做）。</p>
<p>接下来，在我们引用的主样式表（即 <code>style.css</code>）的开头，<strong>加上 <code>@tailwind</code> 指令</strong>：</p>
<pre><code class="language-css">// style<span class="hljs-selector-class">.css</span>
<span class="hljs-keyword">@tailwind</span> base;
<span class="hljs-keyword">@tailwind</span> components;
<span class="hljs-keyword">@tailwind</span> utilities;

<span class="hljs-selector-class">.bg-gray</span> {
    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#aaaaaa</span>;
}
</code></pre>
<p>大功告成。接下来可以尝试修改 HTML 模板并重新 build，就可以发现能使用 Tailwind 了！</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text-4xl&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>（当然，集成到 PostCSS 并不是使用 Tailwind 的唯一方式。官方的<a href="https://tailwindcss.com/docs/installation">Get started</a> 中提供了大量框架、工具的集成指南）</p>
<h3><a id="安装-tailwind-插件" class="content__heading-anchor"></a>安装 Tailwind 插件</h3>
<p>没错，Tailwind 也有插件生态，比如 <strong>tailwindcss-animated</strong>（<a href="https://www.tailwindcss-animated.com">文档</a>）和 <strong>typography</strong>（<a href="https://github.com/tailwindlabs/tailwindcss-typography">文档</a>），这两个插件我都比较常用。</p>
<p>Tailwind 插件配置起来并不难，这里不再展开了，可以查阅相关文档。</p>
<h2><a id="中场休息整理目录结构" class="content__heading-anchor"></a>中场休息：整理目录结构</h2>
<p>至此，CSS 相关的工具配置完了。在进行下一步之前，是时候整理一下我们项目的目录结构了。</p>
<p>如前文所述，为了让项目目录更简洁，<strong>我们将所有源文件移动到新建的 <code>src</code> 文件夹内。</strong>移动之后，项目目录结构如下：</p>
<pre><code>node_modules/
  ...
dist/
  ...
src/
  template.html
  index.js
  style.css
package-lock.json
package.json
postcss.config.js
tailwind.config.js
webpack.config.js
</code></pre>
<p>为了使所有工具只处理 <code>src</code> 目录下的文件，需要修改部分配置文件。</p>
<p>修改 <code>tailwind.config.js</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// tailwind.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">content</span>: [<span class="hljs-string">&quot;./src/**/*.{html,js}&quot;</span>],
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>修改 <code>webpack.config.js</code>：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span>,
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>这下，我们的项目目录就干净了很多。是时候进行下一步了！</p>
<h2><a id="babel" class="content__heading-anchor"></a>Babel</h2>
<p>JavaScript 是浏览器原生支持的唯一语言，但：1）不同浏览器对该语言的新特性支持有所不同；2）许多人不喜欢 JavaScript 弱类型的特性，TypeScript 应运而生。但浏览器本身不支持 TypeScript。</p>
<p>所以，需要这样一种工具：1）将 JavaScript 的新特性相关代码转换为使用旧特性的实现；2）将 TypeScript 翻译为 JavaScript。这个过程和 C++ 这类语言「编译」的过程有些相似，只是目标是 JavaScript 而非二进制。</p>
<p>这种工具就叫做 <strong>transpiler</strong>（可以翻译成「转译器」）。它的作用是将一段代码「翻译」成另一段代码，但目标代码仍然是高级语言（一般是 JavaScript）。这个「翻译」和传统编程语言中的「Compile」概念不同，称为「<strong>Transpile</strong>」。</p>
<p><strong>Babel</strong> 就是其中之一。</p>
<p>（吐槽：既然都要 transpile 才能运行代码，不如直接 compile 成更低级的字节码，执行效率还会更高。<strong>Web Assembly</strong> 就这样诞生了。不过这里不介绍了）</p>
<h3><a id="集成到-webpack-1" class="content__heading-anchor"></a>集成到 webpack</h3>
<p>Babel 可以和 PostCSS 一样<strong>作为 loader 集成在 webpack 里</strong>。安装 Babel：</p>
<pre><code class="language-bash">npm i babel-loader @babel/core --save-dev
</code></pre>
<p>安装后，修改 webpack 配置文件，对 .js 文件使用 <strong>babel-loader</strong>（排除 <code>node_modules</code> 目录中的文件）：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      <span class="hljs-comment">// ...</span>
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,
        },
      },
    ],
  },
};
</code></pre>
<p>（同样，集成到 webpack 也非安装 Babel 的唯一方式。<a href="https://babeljs.io/setup#installation">官方指南</a>提供了很多种配置方式）</p>
<p>目前，重新 build 时，虽然会调用 babel-loader，但是 Babel 还什么事情都没做。这是因为我们没有为其指定任何规则。一般可以通过 <strong>preset</strong> 指定规则。</p>
<h3><a id="presets" class="content__heading-anchor"></a>presets</h3>
<p>Babel 中的 <strong>preset</strong> 这一概念，官方的定义是「可分享的一组插件和配置的集合」（<a href="https://babeljs.io/docs/presets">文档</a>）。</p>
<p>官方提供了四种 preset：</p>
<ul>
<li><strong>env</strong>：用于将较新的 ECMAScript 特性转译为兼容较旧环境的实现。</li>
<li><strong>react</strong>：用于转译 React.js 的 JSX 语法。</li>
<li><strong>typescript</strong>：用于转译 TypeScript。</li>
<li><strong>flow</strong>：用于 <a href="https://flow.org/">flow</a> 工具，这是一个静态类型检查器。</li>
</ul>
<h3><a id="配置文件-babelconfigjson" class="content__heading-anchor"></a>配置文件 babel.config.json</h3>
<p>在项目根目录下创建配置文件 <code>babel.config.json</code>，其中可以添加 preset 指定规则。我们先添加一个 preser-env：</p>
<pre><code class="language-json"><span class="hljs-comment">// babel.config.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>别忘了安装这个 preset：</p>
<pre><code class="language-bash">npm i @babel/preset-env --save-dev
</code></pre>
<p>安装和配置完毕后，重新 build，就会使用 preset-env 指定的 transpile 规则。这套规则有什么用呢？</p>
<h3><a id="preset-env" class="content__heading-anchor"></a>preset-env</h3>
<p>ECMAScript 标准每一两年都推出新的版本，引入新的特性。而不同浏览器对其的实现难免会有所滞后。为了：1）能及时使用 ECMAScript 的新特性；2）确保我们的代码在所有浏览器环境中的表现一致，<strong>Babel 提供的 preset-env 可以将使用新特性的代码 transpile 为使用旧特性的实现。</strong>（<a href="https://babeljs.io/docs/babel-preset-env">文档</a>）（在 Babel 出现之前，许多应用引入一个静态的 js 脚本完成这一功能，这种脚本叫做「polyfill」）</p>
<p>比如，ES6 引入了箭头函数和 const 关键字：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
a.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x));
</code></pre>
<p>如果要兼容不支持 ES6 的环境（虽然所有现代浏览器都已经支持了 ES6），Babel 就要将箭头函数转换成普通函数，const 换成 var：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
a.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
});
</code></pre>
<p>可以在官网的 <a href="https://babeljs.io/repl">Try it out</a> 中尝试。</p>
<h2><a id="typescript" class="content__heading-anchor"></a>TypeScript</h2>
<p>TypeScript 也是开发现代 Web 应用的必备。如果 standalone 地安装，可以使用 <code>tsc</code> 命令将一个 .ts 文件 transpile 成一个 .js 文件。然而，为了使这一过程在 build 时自动完成，还是要将其集成到 Babel。</p>
<h3><a id="集成到-babel" class="content__heading-anchor"></a>集成到 Babel</h3>
<p>如前所述，Babel 已经提供了 TypeScript 的 preset（<a href="https://babeljs.io/docs/babel-preset-typescript">文档</a>），其中包含了转译 TypeScript 的插件。只需直接安装：</p>
<pre><code class="language-bash">npm i @babel/preset-typescript --save-dev
</code></pre>
<p>在 <code>webpack.config.js</code> 中，要修改两个地方：1）将 entry 改为 <code>index.ts</code>；2）将 babel-loader 的 test 规则改为匹配 .ts 结尾的文件：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.ts&quot;</span>,
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      <span class="hljs-comment">// ...</span>
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,
        },
      },
    ],
  },
};

</code></pre>
<p>在 <code>babel.config.json</code> 里，加入 <strong>preset-typescript</strong>：</p>
<pre><code class="language-json"><span class="hljs-comment">// babel.config.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;@babel/preset-typescript&quot;</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>现在，可以将 <code>src</code> 中的 <code>index.js</code> 改写为 <code>index.ts</code> 了。由于这段代码很短，只需要改一个地方，即判断 <code>app</code> 是否为 <code>null</code>：</p>
<pre><code class="language-ts"><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;

<span class="hljs-keyword">const</span> app = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>);
<span class="hljs-keyword">if</span> (app !== <span class="hljs-literal">null</span>) {
  app.<span class="hljs-property">innerText</span> = <span class="hljs-title function_">moment</span>().<span class="hljs-title function_">format</span>();
  app.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&quot;bg-gray&quot;</span>);
}
</code></pre>
<h3><a id="配置文件-tsconfigjson" class="content__heading-anchor"></a>配置文件 tsconfig.json</h3>
<p>TypeScript 也有配置文件。在项目根目录下创建 <code>tsconfig.json</code> 即可。</p>
<p>具体规则可参考<a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">官方文档</a>。当我们配置好 React 后会再来修改 TypeScript 的规则配置。</p>
<h2><a id="reactjs" class="content__heading-anchor"></a>React.js</h2>
<p>使用 React 时我们会编写 <strong>JSX</strong>（或 TSX）语法的代码。JSX（或 TSX）全称 JavaScript（TypeScript）Extension，这是一种糅合了 HTML 和 JavaScript（TypeScript）语法的代码。当然，无论是浏览器还是 Node 都不支持这种代码，<strong>所以需要 Babel 为我们转译</strong>。其实，这样的代码中，类似 HTML 的那部分会被转译成 JavaScript 递归的函数调用的形式。</p>
<h3><a id="集成到-babel-1" class="content__heading-anchor"></a>集成到 Babel</h3>
<p>Babel 也提供了 React 的 preset（<a href="https://babeljs.io/docs/babel-preset-react">文档</a>），包含了对应插件。只要安装：</p>
<pre><code class="language-bash">npm i @babel/preset-react --save-dev
</code></pre>
<p>在 <code>webpack.config.js</code> 中设置匹配 .ts 或 .tsx 结尾的文件：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      <span class="hljs-comment">// ...</span>
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.tsx?$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,
        <span class="hljs-attr">use</span>: {
          <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,
        },
      },
    ],
  },
};
</code></pre>
<p>修改 Babel 配置文件 <code>babel.config.json</code>，添加 <strong>preset-react</strong>：</p>
<pre><code class="language-json"><span class="hljs-comment">// babel.config.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;presets&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;@babel/preset-react&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;@babel/preset-typescript&quot;</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>接下来，为了让 TypeScript 解释 TSX 语法，要在 <code>tsconfig.json</code> 中加入如下配置：</p>
<pre><code class="language-json"><span class="hljs-comment">// tsconfig.json</span>
<span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;strict&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;jsx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;react&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;esModuleInterop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;noEmit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;allowImportingTsExtensions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>这段配置文件中：</p>
<ul>
<li><strong>strict</strong> 设为 true 表示开启严格类型检查，包括不允许隐式 any 类型等等。</li>
<li><strong>jsx</strong> 设为 react，表示启用 JSX 支持。</li>
<li><strong>esModuleInterop</strong> 设为 true 允许用 import 语法直接导入 CommonJS 模块（否则，必须使用 require 的语法）。</li>
<li><strong>noEmit</strong> 表示不输出编译后的结果文件。由于在该配置中 TypeScript 是作为 Babel 的一个插件，转译后结果文件由 Babel 输出。</li>
<li><strong>allowImportingTsExtensions</strong> 表示允许导入 .tsx 类型的文件。</li>
</ul>
<p>以及，现在我们的脚本文件可以是 js、jsx、ts、tsx 格式了，要在 Tailwind 的配置文件中修改其检测的文件格式：</p>
<pre><code class="language-js"><span class="hljs-comment">// tailwind.config.js</span>
<span class="hljs-comment">/** <span class="hljs-doctag">@type</span> {<span class="hljs-type">import(&#x27;tailwindcss&#x27;).Config</span>} */</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">content</span>: [<span class="hljs-string">&quot;./src/**/*.{html,js,jsx,ts,tsx}&quot;</span>],
  <span class="hljs-attr">theme</span>: {
    <span class="hljs-attr">extend</span>: {},
  },
  <span class="hljs-attr">plugins</span>: [],
};
</code></pre>
<p>最后，别忘了安装 <strong>React 本体</strong>，以及其对应的类型定义：</p>
<pre><code class="language-bash">npm i react react-dom --save
npm i @types/react @types/react-dom --save-dev
</code></pre>
<h3><a id="编写-react-组件" class="content__heading-anchor"></a>编写 React 组件</h3>
<p>现在，在 <code>src</code> 下创建 <code>App.tsx</code> 文件，我们可以在其中用 TSX 语法编写一个 React 组件了。</p>
<p>将之前写的显示时间的组件写进这里面：</p>
<pre><code class="language-tsx"><span class="hljs-comment">// App.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>;
<span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;text-4xl&quot;</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{moment().format()}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>为了引用该组件，入口文件 <code>index.ts</code> 也需要用到 TSX 语法。因此，将其重命名为 <code>index.tsx</code>，修改为如下内容：</p>
<pre><code class="language-tsx"><span class="hljs-comment">// index.tsx</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { createRoot } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;

<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App.tsx&quot;</span>;

<span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;app&quot;</span>);
<span class="hljs-keyword">if</span> (container !== <span class="hljs-literal">null</span>) {
  <span class="hljs-keyword">const</span> root = <span class="hljs-title function_">createRoot</span>(container);
  root.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>);
}
</code></pre>
<p>同时，要在 webpack 配置中修改 entry：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.tsx&quot;</span>,
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>现在，build 之后，打开生成的 HTML，可以看到我们用 React 写的组件了。</p>
<h2><a id="eslint" class="content__heading-anchor"></a>ESLint</h2>
<p>ESLint 是一个代码检查工具。对于团队项目，统一代码风格十分重要，而 ESLint 可以方便地做到这一点：如果没有满足指定的代码风格，则显示警告或错误（如果在 IDE 中集成的话），或者拒绝提交或部署（如果在提交部署流程中集成的话）。</p>
<p>为了使流程更加清晰，我们还是选择<strong>将 ESLint 作为一个插件集成到 webpack</strong>。</p>
<h3><a id="集成到-webpack-2" class="content__heading-anchor"></a>集成到 webpack</h3>
<p>安装 <strong>eslint-webpack-plugin</strong>（<a href="https://www.npmjs.com/package/eslint-webpack-plugin">相关文档</a>）：</p>
<pre><code class="language-bash">npm i eslint-webpack-plugin --save-dev
</code></pre>
<p>修改 webpack 的配置，添加该插件：</p>
<pre><code class="language-js"><span class="hljs-comment">// webpack.config.js</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ESLintPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;eslint-webpack-plugin&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ESLintPlugin</span>({
      <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;js&quot;</span>, <span class="hljs-string">&quot;jsx&quot;</span>, <span class="hljs-string">&quot;ts&quot;</span>, <span class="hljs-string">&quot;tsx&quot;</span>],
    }),
  ],
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>配置文件中 <code>new ESLintPlugin({})</code> 可以传入一个 options 对象，用于指定 <strong>ESLint 插件选项</strong>（<a href="https://www.npmjs.com/package/eslint-webpack-plugin">文档</a>）。这里我们指定了要 lint 的文件拓展名。</p>
<h3><a id="配置文件-eslintrcjs" class="content__heading-anchor"></a>配置文件 .eslintrc.js</h3>
<p>可以使用 <code>@eslint/config</code> 创建配置文件（<a href="https://eslint.org/docs/latest/use/getting-started">文档</a>），这是一个友好的交互式命令：</p>
<pre><code class="language-bash">npm init @eslint/config
</code></pre>
<p>在其中可以选择「项目使用了 React.js、TypeScript」，该命令会自动为我们安装配置对应的 ESLint 插件。</p>
<p>运行完成后，除了安装了一堆插件，项目根目录会产生配置文件 <code>.eslintrc.js</code>（或者其他文件格式，取决于你的选择）。</p>
<pre><code class="language-js"><span class="hljs-comment">// .eslintrc.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">env</span>: {
    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">es2021</span>: <span class="hljs-literal">true</span>,
  },
  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&quot;standard-with-typescript&quot;</span>, <span class="hljs-string">&quot;plugin:react/recommended&quot;</span>],
  <span class="hljs-attr">overrides</span>: [
    {
      <span class="hljs-attr">env</span>: {
        <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>,
      },
      <span class="hljs-attr">files</span>: [<span class="hljs-string">&quot;.eslintrc.{js,cjs}&quot;</span>],
      <span class="hljs-attr">parserOptions</span>: {
        <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;script&quot;</span>,
      },
    },
  ],
  <span class="hljs-attr">parserOptions</span>: {
    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-string">&quot;latest&quot;</span>,
    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>,
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&quot;react&quot;</span>],
};
</code></pre>
<p>现在，再次 build，ESLint 会按照我们设定的规则进行代码检查。</p>
<p>可以在配置文件中添加一些自己习惯的规则，比如使用双引号、行末加分号。并且，需要设置对于 <code>*.config.js</code> 这类配置文件的特殊检测规则。我的 <code>.eslintrc.js</code> 文件设置如下：</p>
<pre><code class="language-js"><span class="hljs-comment">// .eslintrc.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">env</span>: {
    <span class="hljs-attr">browser</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">es2021</span>: <span class="hljs-literal">true</span>
  },
  <span class="hljs-attr">extends</span>: [<span class="hljs-string">&quot;standard-with-typescript&quot;</span>, <span class="hljs-string">&quot;plugin:react/recommended&quot;</span>],
  <span class="hljs-attr">overrides</span>: [
    {
      <span class="hljs-attr">env</span>: {
        <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span>
      },
      <span class="hljs-attr">files</span>: [<span class="hljs-string">&quot;.eslintrc.js&quot;</span>, <span class="hljs-string">&quot;*.config.js&quot;</span>],
      <span class="hljs-attr">parserOptions</span>: {
        <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;script&quot;</span>
      },
      <span class="hljs-attr">extends</span>: [<span class="hljs-string">&quot;plugin:@typescript-eslint/disable-type-checked&quot;</span>],
      <span class="hljs-attr">rules</span>: {
        <span class="hljs-string">&quot;@typescript-eslint/no-var-requires&quot;</span>: <span class="hljs-string">&quot;off&quot;</span>
      }
    }
  ],
  <span class="hljs-attr">parserOptions</span>: {
    <span class="hljs-attr">ecmaVersion</span>: <span class="hljs-string">&quot;latest&quot;</span>,
    <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&quot;module&quot;</span>
  },
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-string">&quot;@typescript-eslint/semi&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;always&quot;</span>],
    <span class="hljs-string">&quot;@typescript-eslint/quotes&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;double&quot;</span>]
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&quot;react&quot;</span>]
};
</code></pre>
<p>⚠️ <strong>一个坑点：</strong>使用 TypeScript 时，由于使用 typescript-eslint 的解析器而非默认解析器（<a href="https://github.com/mightyiam/eslint-config-standard-with-typescript">文档</a>），添加规则要写 <code>@typescript-eslint/quotes</code> 而非 <code>quotes</code>，否则不会生效。例如：</p>
<pre><code class="language-js"><span class="hljs-comment">// eslintrc.js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">rules</span>: {
    <span class="hljs-string">&quot;@typescript-eslint/quotes&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;double&quot;</span>],
    <span class="hljs-string">&quot;@typescript-eslint/semi&quot;</span>: [<span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;always&quot;</span>],
  },
  <span class="hljs-comment">// ...</span>
};
</code></pre>
<p>💡 或许你同时在 IDE 中使用 <strong>Prettier</strong> 一类的<strong>代码格式化工具</strong>。其文档中 <a href="https://prettier.io/docs/en/comparison">Prettier vs. Linters</a> 介绍了这两种工具的区别；<a href="https://prettier.io/docs/en/integrating-with-linters.html">Integrating with Linters</a> 介绍了其与 linter 的集成指南。简而言之，在 ESLint 配置中应用 <a href="https://github.com/prettier/eslint-config-prettier">eslint-config-prettier</a> 规则集即可自动关闭所有与 Prettier 冲突的规则。不过我更推荐的是在 IDE 中安装 ESLint 插件，对于 js 类文件直接使用 ESLint 作为代码格式化工具，这样能够确保遵循 eslintrc 中的规则。</p>
<p>（ESLint 这部分配置起来还是挺麻烦的，尤其要集成到 VSCode，同时兼容 TypeScript，并考虑到其和 Prettier 的冲突。改天配置好了一个比较 fancy 的方案再单独写一篇）</p>
<h2><a id="recap站在巨人的肩膀上" class="content__heading-anchor"></a>Recap：站在巨人的肩膀上</h2>
<p>至此，一套比较完整的<strong>前端项目 starter</strong> 终于配置完毕了。完整的项目可以在<a href="https://github.com/Skywt2003/starter.git">这个仓库</a>查看。</p>
<p>回顾一下，我们首先使用了 <strong>webpack</strong> 作为打包工具；其 <strong>PostCSS</strong> 插件能够对 CSS 进行处理；<strong>Tailwind</strong> 则可以作为 PostCSS 插件集成。我们使用 <strong>Babel</strong> 这个 transpiler 处理各种脚本文件，其中 <strong>env</strong> preset 将 ECMAScript 较先进的特性转译为旧特性的实现，确保兼容性；<strong>TypeScript</strong> 和 <strong>React JSX</strong> 两个 preset 则分别将它们各自的语法转译成 JavaScript。最后，我们使用 <strong>ESLint</strong> 作为代码质量检查工具，并配置其针对 TypeScript 和 JSX 的规则。</p>
<p>使用的工具链关系示意图如下：</p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/03/543791890.png" data-fancybox data-caption="配置完毕后的工具链示意图"><img src="https://blog.skywt.cn/usr/uploads/2024/03/543791890.png" alt="配置完毕后的工具链示意图" title="配置完毕后的工具链示意图" /></a></p>
<p>相比从前，各种工具让开发的过程变得越来越优雅和美妙。然而每个工具背后，都有无数前人的辛勤付出，没有他们的这些努力，我们无法得到这样现代化的前端开发体验。</p>
<p>现代前端开发，就是<strong>站在巨人的肩膀上</strong>。</p>
<h3><a id="一点思考-🤔" class="content__heading-anchor"></a>一点思考 🤔</h3>
<p>最后，还有一个我的疑问：<strong>相比其他领域，为什么 Web 前端开发的工具链会呈现如此复杂的形态呢？</strong>我体验过 iOS 开发，也了解过基于 Qt 等框架的客户端开发，我个人的感觉是没有一个领域的客户端开发像 Web 前端这样有如此庞大复杂的工具链：某个工具可以配置插件，插件又有插件，插件的插件又有插件……那么归根结底，Web 前端工具链这种复杂的形式，是历史发展的必然，是某种设计缺陷的后果，还是某种设计思想的体现？🤔</p>
<p>欢迎分享你的思考。</p>
<h2><a id="值得一读" class="content__heading-anchor"></a>值得一读</h2>
<blockquote>
<p>Web development used to be a great entry point for people new to programming precisely because it was so easy to get up and running; nowadays it can be quite daunting, especially because the various tools tend to change rapidly.</p>
<p>—— Modern JavaScript Explained For Dinosaurs</p>
</blockquote>
<p><strong>值得一读的相关文章；</strong></p>
<ul>
<li><a href="https://peterxjang.com/blog/modern-javascript-explained-for-dinosaurs.html">Modern JavaScript Explained For Dinosaurs</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Introducing_complete_toolchain">介绍完整的工具链 - 学习 Web 开发 | MDN</a></li>
<li><a href="https://pomb.us/build-your-own-react/">Build your own React</a></li>
</ul>
 </article> </section> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script> <hr class="page__divide page__divide--between-sections"> <astro-island uid="1HpeMr" prefix="r0" component-url="/_astro/Comments.BdzVuXw3.js" component-export="default" renderer-url="/_astro/client.BIGLHmRd.js" props="{&quot;articleId&quot;:[0,159]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;Comments&quot;,&quot;value&quot;:true}" await-children=""><section class="page__section"><h2><i class="ri-discuss-line"></i> 暂无评论</h2></section><hr class="page__divide page__divide--between-sections"/><section class="page__section"><h2><i class="ri-discuss-line"></i> 发表新的评论</h2><p class="mt-4 card card--in-content"><b>所有评论都将经过博主审核。</b>请勿填写无意义邮箱或发表无关评论、广告等，否则会被视为垃圾评论。</p><form class="mt-4 form"><input placeholder="你的名字" type="text" class="form__input" required="" value=""/><input placeholder="邮箱" type="email" class="form__input" required="" value=""/><input placeholder="网址" type="url" class="form__input" value=""/><textarea rows="8" class="sm:col-span-3 form__input" placeholder="说点什么吧……" required=""></textarea><button type="submit" class="sm:col-span-3 form__button">提交</button></form><p class="mt-4 text-secondary text-sm leading-normal">提交评论即表明你同意本网站使用 Cookie，并允许本站在后台记录你的邮箱、IP 地址等必要信息。这些信息不会被透露给其他用户。（提交一次评论后，本提示将不再展示）</p></section><!--astro:end--></astro-island>  </main>  <footer class="footer"> <div class="footer__row"> <div class="m-2"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
从零开始，配置一套现代前端工具链 </span> </div> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv>  友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">SkyWT</a> |
<a href="/sitemap-index.xml" class="link">站点地图</a>
|
<a href="/friends" class="link">友情链接</a>
|
<a href="https://foreverblog.cn/go.html" target="_blank" class="link">虫洞</a> </p> <p class="m-2"> <a href="https://www.boyouquan.com/" target="_blank" class="mx-1"> <img src="/boyouquan.png" alt="Boyouquan Badge" class="inline-block h-4 grayscale"> </a> <a href="https://www.foreverblog.cn/" target="_blank" class="mx-1"> <img src="/forever_blog.png" alt="Forever Blog Badage" class="inline-block h-4 grayscale"> </a> <a href="https://blogscn.fun/" target="_blank" class="mx-1"> <img src="/blogscn.png" alt="BLOGS·CN Badge" class="inline-block h-4 grayscale"> </a> </p> </div> <div class="footer__row"> <p class="m-2"> <a href="https://beian.miit.gov.cn/" target="_blank" class="link">
浙 ICP 备 2021019606 号 - 1</a>
|
<a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33080202000472" target="_blank" class="link before:content-[url('/mps.png')] before:align-middle">
浙公网安备 33080202000472 号</a> </p> <div class="m-2"> <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" class="inline-block mx-1" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/cc.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/by.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/nc.svg" data-astro-cid-h3ykra2n>   </a>  <a href="https://notbyai.fyi" target="_blank" class="inline-block mx-1" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-light.svg" alt="Not By AI Badge" class="badge inline-block dark:hidden" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-dark.svg" alt="Not By AI Badge" class="badge hidden dark:inline-block" data-astro-cid-hwbnc4sm> </a>  </div> </div> </footer> </body></html> 